NBER WORKING PAPER SERIES

SIMPLICITY CREATES INEQUITY:
IMPLICATIONS FOR FAIRNESS, STEREOTYPES, AND INTERPRETABILITY
Jon Kleinberg
Sendhil Mullainathan
Working Paper 25854
http://www.nber.org/papers/w25854

NATIONAL BUREAU OF ECONOMIC RESEARCH
1050 Massachusetts Avenue
Cambridge, MA 02138
May 2019

The views expressed herein are those of the authors and do not necessarily reflect the views of the
National Bureau of Economic Research.
NBER working papers are circulated for discussion and comment purposes. They have not been
peer-reviewed or been subject to the review by the NBER Board of Directors that accompanies
official NBER publications.
© 2019 by Jon Kleinberg and Sendhil Mullainathan. All rights reserved. Short sections of text,
not to exceed two paragraphs, may be quoted without explicit permission provided that full
credit, including © notice, is given to the source.

Simplicity Creates Inequity: Implications for Fairness, Stereotypes, and Interpretability
Jon Kleinberg and Sendhil Mullainathan
NBER Working Paper No. 25854
May 2019
JEL No. C54,C55,D8,I30,J7,K00
ABSTRACT
Algorithms are increasingly used to aid, or in some cases supplant, human decision-making,
particularly for decisions that hinge on predictions. As a result, two additional features in addition
to prediction quality have generated interest: (i) to facilitate human interaction and understanding
with these algorithms, we desire prediction functions that are in some fashion simple or
interpretable; and (ii) because they influence consequential decisions, we also want them to
produce equitable allocations. We develop a formal model to explore the relationship between the
demands of simplicity and equity. Although the two concepts appear to be motivated by
qualitatively distinct goals, we show a fundamental inconsistency between them. Specifically, we
formalize a general framework for producing simple prediction functions, and in this framework
we establish two basic results. First, every simple prediction function is strictly improvable: there
exists a more complex prediction function that is both strictly more efficient and also strictly
more equitable. Put another way, using a simple prediction function both reduces utility for
disadvantaged groups and reduces overall welfare relative to other options. Second, we show that
simple prediction functions necessarily create incentives to use information about individuals'
membership in a disadvantaged group—incentives that weren't present before simplification, and
that work against these individuals. Thus, simplicity transforms disadvantage into bias against the
disadvantaged group. Our results are not only about algorithms but about any process that
produces simple models, and as such they connect to the psychology of stereotypes and to an
earlier economics literature on statistical discrimination.

Jon Kleinberg
Department of Computer Science
Department of Information Science
Cornell University
Ithaca, NY 14853
kleinber@cs.cornell.edu
Sendhil Mullainathan
Booth School of Business
University of Chicago
5807 South Woodlawn Avenue
Chicago, IL 60637
and NBER
Sendhil.Mullainathan@chicagobooth.edu

Simplicity Creates Inequity:
Implications for Fairness, Stereotypes, and Interpretability
Jon Kleinberg∗

Sendhil Mullainathan†

Abstract
Algorithms are increasingly used to aid, or in some cases supplant, human decision-making,
particularly for decisions that hinge on predictions. As a result, two additional features in
addition to prediction quality have generated interest: (i) to facilitate human interaction and
understanding with these algorithms, we desire prediction functions that are in some fashion
simple or interpretable; and (ii) because they influence consequential decisions, we also want
them to produce equitable allocations. We develop a formal model to explore the relationship between the demands of simplicity and equity. Although the two concepts appear to be
motivated by qualitatively distinct goals, we show a fundamental inconsistency between them.
Specifically, we formalize a general framework for producing simple prediction functions, and in
this framework we establish two basic results. First, every simple prediction function is strictly
improvable: there exists a more complex prediction function that is both strictly more efficient
and also strictly more equitable. Put another way, using a simple prediction function both
reduces utility for disadvantaged groups and reduces overall welfare relative to other options.
Second, we show that simple prediction functions necessarily create incentives to use information about individuals’ membership in a disadvantaged group — incentives that weren’t present
before simplification, and that work against these individuals. Thus, simplicity transforms disadvantage into bias against the disadvantaged group. Our results are not only about algorithms
but about any process that produces simple models, and as such they connect to the psychology
of stereotypes and to an earlier economics literature on statistical discrimination.

1

Introduction

Algorithms can be a powerful aid to decision-making — particularly when decisions rely, even
implicitly, on predictions [23]. We are already seeing algorithms play this role in domains including
hiring, education, lending, medicine, and criminal justice [8, 22, 34, 36]. Across these diverse
contexts, the role for algorithms follows a similar template: applicants present themselves to be
evaluated by a decision-maker who chooses an accept/reject outcome for each applicant — for
example, whether they are hired, admitted to a selective school, offered a loan, or released on bail.
The final decision-making authority in these situations typically rests with a human being or a
committee of human beings. But because the decisions turn on a prediction of some underlying
quantity (such as crime risk in the case of bail or default risk in the case of a loan), decision-makers
are beginning to rely on the assistance of algorithms that map features of each applicant to a
numerical prediction.
∗
†

Departments of Computer Science and Information Science, Cornell University
University of Chicago Booth School of Business

1

As is typical in machine learning applications, accuracy, evaluated by some measure of admitted
applicants’ future performance, is an important measure. In these high-stakes policy contexts,
though, two additional considerations prove important as well, as highlighted by recent work:
• Fairness and equity. Certain groups in society are disadvantaged in clear-cut quantitative ways
— on average they graduate from less-resourced educational institutions, live in areas with
reduced economic opportunities, and face other socioeconomic challenges in aggregate. Will
an algorithmic approach, based on these underlying measures, perpetuate (or even magnify)
the underlying disadvantage? Or could we use algorithms to increase equity between groups?
[4, 9, 12, 14]
• Interpretability. Algorithms tend to result in complex models that are hard for human beings
to comprehend. Yet in these domains, humans work intimately with them. Can a decisionmaker derive understanding from such an algorithm’s output, or are they forced to treat it
as a “black box” that produces pure numerical predictions with no accompanying insight?
And similarly, can an applicant derive any understanding about the basis for the algorithm’s
prediction in their particular case? [11, 28, 38]
Fairness and interpretability are clearly distinct issues, but it is natural to suspect that there
may be certain interactions between them. A common theme in the literature on interpretability
is the possibility that interpretable models can be more easily examined and audited for evidence
of unfairness or bias; as one of many examples of this theme, Doshi-Velez and Kim argue that “interpretability can assist in qualitatively ascertaining whether other desiderata — such as fairness,
privacy, reliability, robustness, causality, usability and trust — are met” [11]. Nor is this point
purely an issue in academic research: the formulation of the European Union General Data Protection Regulation (GDPR) reinforces earlier EU regulations asserting that individuals have a “right
to explanation” when they are affected by algorithmic decision-making. The technical implications
of these guidelines are not yet fully clear, but their premise situates interpretable decisions as a
component of fair outcomes [17, 28].
The present work: A basic tension between fairness and simplicity. There are many
ways in which interpretability may be able to help promote fairness — they might be more easily
analyzable and auditable, as noted above; and the activity of constructing an interpretable rule,
depending how it is carried out, may be able to engage more participants in the process.
But there has been arguably less exploration of what, if anything, we give up with respect to
fairness and equity when we pursue interpretable rules. Here we consider a set of questions in
this direction, focusing in particular on the role of simplicity in the construction of prediction rules.
Simplification is one of the common strategies employed in the construction of interpretable models,
and this is for natural reasons. A primary source of model complexity is “width” — the number of
variables, or applicant features, that are used. Humans typically struggle to understand very wide
models, and so to create interpretable or explainable models, many standard approaches seek, at
some level, to reduce the number of variables that go into in any one decision. There are many ways
to do this: for example, we could project the space of features onto a small number of the most
informative variables; we could enumerate short “rules” that only depend on a few variables; we
could construct a shallow decision tree that only consults a small number of variables on any path
from its root to a leaf. Despite the diversity in these approaches, they follow a common principle:

2

they all simplify the underlying model by combining distinguishable applicants into larger sets and
making a common decision at the level of each set.
Our main results show that when one group of individuals is disadvantaged with respect to
another, there is a precise sense in which the process of simplifying a model will necessarily hurt
natural measures of fairness and equity.
The present work: Summary of results. The exact statement of our results will be made
precise via the model that we develop starting in the next section, but roughly speaking they proceed
as follows. We first formalize the above notion of simplicity: given applicants with feature vectors,
and a function for ranking applicants in terms of their feature vectors, we say that a simplification
of this function is a partitioning of the feature vectors into cells, such that each cell is obtained by
fixing the values of certain dimensions in the feature vector and leaving others unrestricted. A fixed
value is assigned to each cell, computed as the average value of all the applicants who are mapped
to the cell. This generalizes, for example, the structure we obtain when we project the function
onto a reduced number of variables, or group applicants using a short decision tree or decision list.
We say that a simplification is non-trivial if at least some of its cells average together applicants of
different underlying values.
We show that under these definitions, when one group experiences disadvantage relative to
another, non-trivial simplifications of a function exhibit two problems: they can be strictly improved, and they create incentives to explicitly use information about an applicant’s membership
in a disadvantaged group. We describe each of these problems in more detail.
First, we will prove that any non-trivial simplification of a function is strictly improvable: it can
be replaced with a more complex function which produces an outcome that is simultaneously more
accurate overall and also more equitable toward the disadvantaged group. Thus, whatever one’s
preferences for accuracy and equity in a model, the complex function dominates the simple one. In
the language of optimization, this means that every simple model is strictly Pareto-dominated —
since it can be improved in both accuracy and equity simultaneously, it never represents the best
trade-off between these two criteria.
Now, it is intuitively natural that one can improve on the accuracy of a simple model: much
of the literature in this area is organized in terms of a trade-off between interpretability and
performance. But as the above discussion illustrates, it has generally been imagined that we are
agreeing to this trade-off because interpretability brings collateral benefits like the promotion of
fair and equitable outcomes. This is the aspect of the earlier arguments that our result calls
into question: in a formal sense, any attempt at simplification in fact creates inequities that a
more complex model could eliminate while also improving performance. Achieving interpretabilty
through simplification sacrifices not only performance but also equity.
Simplifying a function also introduces a second problem. Suppose that the true function for
ranking applicants does not depend on group membership — applicants who differ only in their
group receive identical evaluations by this true function. As a result, the ranking by the true (complex) function would be the same whether or not group membership was known. We show, however,
that simple functions that do not use group membership can always be made more accurate if they
are given access to group membership information. Moreover, this improvement in accuracy comes
at the cost of reducing equity toward the disadvantaged group: faced with two otherwise identical
applicants, the one from the disadvantaged group would be ranked lower. This creates a troubling
contrast: with the original function, a decision-maker concerned with maximizing accuracy had

3

no interest in which group an applicant belonged to; but once we simplify the function in any
non-trivial way, the decision-maker suddenly has an interest in using group membership in their
ranking, and in a way that hurts the disadvantaged group. Put informally, simple functions create
an incentive to “seek out” group membership for purposes of discriminating against the disadvantaged group, in a way that more complex functions don’t. Simplification transforms disadvantage
into explicit bias.
A concrete example helps illustrate these two ways in which simplicity sacrifices equity. Suppose
that a college, to simplify its ranking of applicants, foregoes the use of admissions essays for all
students. (This is in keeping with the type of simplification discussed above: in the representation
of each applicant, the college is grouping applicants into cells by projecting out the dimension corresponding to the quality of the essay.) In doing so, it harms those disadvantaged students with
excellent essays: they now have no way of showing their skill on this dimension. Moreover, suppose that the disadvantaged group has a lower fraction of applicants with strong essays, precisely
because students from the disadvantaged group come from less-resourced educational institutions.
Then the college’s simplified evaluation creates a perverse incentive to use an applicant’s advantaged/disadvantaged status as an explicit part of the ranking, because group membership conveys
indirect information about the average quality of the (unseen) essay. Simplification not only means
that members of the disadvantaged group have fewer ways of showing their skill; it also transforms
group status into a negative feature. Though this is one specific example, the machinery of our
proof shows that such problems are endemic to all forms of simplification in this style.
Recent empirical work also provides revealing analogues to these results. In particular, recent
studies have investigated policies that seek to limit employers’ access to certain kinds of job applicant information. For example, “ban-the-box” policies prevent employers from asking whether
applicants have criminal records, with the goal of helping those applicants with prior criminal
convictions. A striking study of Agan and Starr argued that such policies can have unintended
consequences: through a large field experiment measuring callbacks for hiring they found that when
localities implemented ban-the-box policies, racial disparities increased significantly [1]. One of the
main interpretations of this finding can be understood in terms of simplification: by eliminating
a feature of an applicant (existence of a criminal record) that is correlated with membership in a
disadvantaged group and would have been used in the decision, the policy creates an unintended
incentive to make greater explicit use of membership in this disadvantaged group instead as part
of the decision.
Further Interpretations. The scope of our results are both more specific and more general
than they may initially appear. First, it is important to keep in mind that our work is based on a
particular definition of simplicity. While the definition is quite general, and captures many of the
formalisms in wide use, there are other ways in which simplicity could be formulated, and these
alternative formulations may lead to different structures than what we describe here. And beyond
this, the notion of interpretability is more general still; simplification is only one of the standard
strategies used in developing interpretable models. Thus, in addition to the results themselves, we
hope our work can help lay the groundwork for thinking about the interaction of fairness, simplicity,
and interpretability more generally.
At the same time, our notion of simplicity can be motivated in several independent ways beyond
the initial considerations of interpretability. In particular, we may be using a simple model because
more complicated models are computationally complex and time-consuming to fit. Data collection

4

costs could lead to measuring fewer variables. At an even more fundamental level, machine learning
methods naturally give rise to simplicity. To address over-fitting, procedures that estimate highdimensional models typically choose a simpler model that fits worse in-sample but performs better
out-of-sample [19]. For example, the process of growing a decision tree generally has a stopping
condition that prevents the number of instances being mapped to a single node from getting too
small; further refinement of the tree may provide signal but will not be undertaken because the
magnitude of that signal does not exceed a specified regularization penalty. All these diverse
motivations may provide important reasons to pursue simplification in a range of contexts. The
central point of our framework here, however, is to identify a further cost inherent in these choices
— that simplification gives up some amount of equity.
Additionally, concerns about accuracy, fairness, and simplicity are relevant not just to algorithmic decisions but to purely human ones as well; and therefore much of our analysis implies
fundamental constraints on any system for decision-making, whether algorithmic or human. To
the extent that human beings think in categories, these categories can be viewed as coarse simplifications and our results also apply to them [31, 32]. Indeed, our findings suggest a connection to
an important issue in human psychology — the construction of stereotypes [18, 27]. If we think of
stereotyping as a process of taking distinguishable individuals and grouping them together so as to
treat them similarly, then our results show that when there is disadvantage between groups, all ways
of stereotyping will increase inequity. And in this way, we also arrive at a possible counterweight to
the earlier intuitions about interpretability and its potential benefits for fairness: requiring an algorithm to work with a model of reduced complexity is effectively asking it to construct stereotypes
from the data, and this activity reduces not only performance but also equity.

2

An Informal Overview of the Model

It will be useful to provide an informal overview of the model before specifying it in detail.
The model represents the process of admissions or screening: we have a set of applicants, and
we would like to admit a fraction r of them, a quantity we will refer to as the admission rate. We
can think of this process for example as one of hiring, or lending, or admission to a selective school.
Each applicant is described by a feature vector, and they also belong to one of two groups: an
advantaged group A or a disadvantaged group D. There is a function f that maps each individual
to their qualifications for purposes of admission: f represents whatever criterion we care about for
the admission process. We assume f is an arbitrary function of an applicant’s feature vector but
does not depend on group membership; if two applicants have the same feature vector but belong
to different groups, they have the same f -value. Thus, group membership has no true effect on
someone’s qualifications as an applicant. However, group D does experience disadvantage, in the
sense that a smaller proportion of the applicants in group D have feature vectors that produce
large values of f .
Now, the basic task is to assign each applicant a score, so that applicants can be ranked in
decreasing order of this score, and then the top r fraction can be admitted. The basic two measures
that we would like to optimize in admissions are the efficiency of the admitted set, defined as the
average f -value of the admitted applicants, and the equity of the admitted set, defined as the
fraction of admitted applicants who come from group D. Perhaps the most natural score to assign
each applicant is their true f -value; this makes sense from the perspective of efficiency, since we
are admitting a subset of the applicants whose f -values are as high as possible.
5

But this is where the issue of simplification comes in. It may be that f is too complicated
or impractical to work with, or even to represent; or we would like a more interpretable score;
or perhaps we are hoping that by simplifying f we might improve equity (even at the cost of
potentially reducing efficiency). Thus, we consider simpler scores g, obtained by grouping sets of
feature vectors into larger cells of applicants who will be treated the same, and assigning a group
average score to all the applicants in a single cell. Not every way of partitioning feature vectors
into cells should be viewed as “simple”; some partitions, for example, would arguably be more
complicated to express than f itself. We thus think of g as a simple score if each of its cells
has the following structured representation: we fix the values of certain dimensions of the feature
vector, taking all applicants who match the values in these dimensions, and leaving the values
of all other dimensions unspecified. As we discuss further in the next section, many of the most
natural formalisms for creating simple or interpretable functions have this structure, and thus we
are abstracting a practice that is standard across multiple different methods.
Main Results. From here we can informally state our first main result as follows: for every
admission rule based on a simple function g, there is a different function h (possibly not simple),
such that if we admit applicants using h instead of g, then both the resulting efficiency and the
resulting equity are at least as good for every admission rate r; and both are strictly better for
some admission rate r0 . Thus, however our preferences for efficiency and equity are weighted, we
should prefer h to g. In other words, simple rules are strictly Pareto-dominated: a simple rule never
represents the best trade-off between efficiency and equity, since it can be simultaneously improved
in both respects.
The proof of this first result, informally speaking, starts with an arbitrary simple function and
looks for a cell that either contains applicants from group D whose f -values are above the average
score in the cell, or contains applicants from group A whose f -values are below the average score
in the cell. In either case, by separating these applicants out into a distinct cell, we end up with
a new function that has moved forward in its ranking applicants with higher average f -values and
higher representation from group D, resulting in a strict improvement. The key issue in the proof
is to show that one of these improving operations is always possible, for any simple function.
We also show a second result, using the notion of a group-agnostic simplification of f — a score
g based on combining feature vectors into cells in such a way that applicants who differ only in
group membership are mapped to the same cell. We show that when we incorporate knowledge
of group membership into g — by “splitting” each cell into distinct cells for the applicants from
groups A and D respectively — the efficiency of the resulting admission rule goes up, and the equity
goes down. We conclude that even though group membership is irrelevant to the true value of f ,
any group-agnostic simplification of f creates an incentive for a decision-maker to use knowledge
of group membership — an incentive that wasn’t present before simplification, and one that hurts
the disadvantaged group D.
With this as the overview, we now give a more formal description of the model.

6

3
3.1

A Model of Simplicity and Equity
Feature Vectors, Productivity, and Disadvantage

We begin with feature vectors. Each applicant is described by a feature vector consisting of k
attributes xh1i , . . . , xhki , where each xhii is a Boolean variable taking the value 0 or 1. (Later we will
see that the assumption that the variables are Boolean is not crucial, but for now it is useful for
concreteness.) As discussed above, each applicant also belongs to one of two groups: an advantaged
group named A or a disadvantaged group named D. (We will sometimes refer to the applicants
from these groups as A-applicants and D-applicants respectively.) The group membership of the
applicant can be thought of as a Boolean variable that we denote γ, taking the value A or D, which
gives the applicant an extended feature vector (xh1i , . . . , xhki , γ) with k + 1 dimensions. As a matter
of notation, we will use x, or sometimes a subscripted variable like xi , to denote a k-dimensional
feature vector of the form (xh1i , . . . , xhki ) (without the group membership variable γ), and we will
use x or (x, γ) to denote an extended feature vector of the form (xh1i , . . . , xhki , γ). Sometimes we
will use xhk+1i to denote the group membership variable γ, so that the extended feature vector of
an applicant can be written (xh1i , . . . , xhki , xhk+1i ).
The productivity function. Each applicant has a productivity that is a function of their feature vector, and our goal is to admit applicants of high productivity. In what follows, we don’t
impart a particular interpretation to productivity except to say that we prefer applicants of higher
productivity; thus, productivity can correspond to whatever criterion determines the true desired
rank-ordering of applicants. We write f (x, γ) for the productivity of an applicant with extended
feature vector (x, γ). We will think of the values of f as being specified by a look-up table, where
each extended feature vector (x, γ) is a row in the table; we will therefore often refer to extended
feature vectors as “rows.”
We make the assumption that group membership has no effect on productivity when the values
of all the other features are fixed; that is, for every k-dimensional feature vector x, we have f (x, A) =
f (x, D). Thus, in a mild abuse of notation, we will sometimes write f (x) for this common value
f (x, A) = f (x, D). We will also make the genericity assumption that f (x) 6= f (x0 ) for distinct
k-dimensional feature vectors x, x0 . (This is part of a broader genericity assumption that we state
below.)
Measures and Disadvantage. We now make precise the quantitative sense in which group D
experiences disadvantage relative to group A: even though f (x, A) = f (x, D) for all x, a smaller
fraction of group D exhibits feature vectors x corresponding to larger (and hence more desirable)
values of the productivity f . This is a natural way to think about disadvantage for our purposes:
conditional on the full set of features x, group membership has no effect on the value of f , but
members of group D in aggregate have fewer opportunities to obtain feature vectors that produce
large values of f .
We formalize this using the following definitions. Let µ(x, γ) denote the fraction of the population whose extended feature vector is equal to the row (x, γ); we will refer to this as the measure of
row (x, γ). We will assume that every row has a positive measure, µ(x, γ) > 0. The disadvantage
condition then states that feature vectors yielding larger values of f have higher representation of
group A:

7

(3.1)

(Disadvantage condition.) If x and x0 are feature vectors such that f (x) > f (x0 ), then
µ(x0 , A)
µ(x, A)
>
.
µ(x, D)
µ(x0 , D)

As one way to think about this formalization of disadvantage, we can view the population
fractions associated with each feature vector as defining two distributions over possible values of
f : a distribution over f -values for the advantaged group, and a distribution over f -values for
the disadvantaged group. The condition in (3.1) is equivalent to saying that the distribution for
the advantaged group exhibits what is known as likelihood-ratio dominance with respect to the
distribution for the disadvantaged group [3, 20, 30, 37]; this is a standard way of formalizing the
notion that one distribution is weighted toward more advantageous values relative to another, since
it has increasingly high representation at larger values. It is interesting, however, to ask how much
we might be able to weaken the disadvantage condition and still obtain our main results; we explore
this question later in the paper, in Section 7.
Averages. There is another basic concept that will be useful in what follows: taking the average
value of f over a set of rows. This is defined simply P
as follows. For a set of rows S, let µ(S) denote
the total measure of all rows in S: that is, µ(S) = x∈S µ(x). We then write f |S for the average
value of f on applicants in rows of S; that is,
P
µ(x)f (x)
f |S = x∈S
.
µ(S)
In terms of these average values, we can also state our full genericity assumption: beyond the
condition f (x, A) = f (x, D), there are no “coincidental” equalities in the average values of f .
(3.2) (Genericity assumption.) Let S and T be two distinct sets of rows such that if S = {(x, A)}
then T 6= {(x, D)}. Then f |S 6= f |T .
Note that this genericity assumption holds for straightforward reasons if we think of all f values as perturbed by random real numbers drawn independently from an arbitrarily small interval
[−ε, ε].1 The key point is that when the genericity condition does not hold, there is already some
amount of “simplification” being performed by identities within f itself; we want to study the
process of simplification when — as is typical in empirical applications — f is not providing such
simplifying structure on its own. (To take one extreme example of a failure of genericity, suppose
the function f didn’t depend at all on one of the variables xhii ; then we could clearly consider a
version of the function that produced the same output without consulting the value of xhii , but
this wouldn’t in any real sense constitute a simplification of f .)

3.2

Approximators

We will consider admission rules that rank applicants and then admit them in descending order.
One option would be to rank applicants by the value of f ; but as discussed above, there are many
reasons why we may also want to work with a simpler approximation to f , ranking applicants by
their values under this approximation. We call such a function g an f -approximator; it is defined
1

To clarify one further point, note that if U is a set of k-dimensional feature vectors of size greater than one, and
S = {(x, A) : x ∈ U } and T = {(x, D) : x ∈ U }, then f |S 6= f |T follows purely from the disadvantage condition.

8

by specifying a partition of the applicant population into a finite set of cells C1 , C2 , . . . , Cd , and
approximating the value in each cell Ci by a number θ(Ci ) equal to the average value of f over the
portion of the population that lies in Ci . Because we will be using the function g to rank applicants
for admission, we will require that the cells of g are sorted in descending order:2 θ(Ci ) ≥ θ(Cj ) for
i < j.
A key point in our definition is that an f -approximator g operates by simply specifying the
partition into cells; the values associated with these cells are determined directly from the partition,
as the average f -value in each cell. This type of “truth-telling” constraint on the cell values is
consistent with our interest in studying the properties of approximators as prediction functions.
Subsequent decisions that rely on an approximator g could in principle post-process its values in
multiple ways, but our focus here — as a logical underpinning for any such further set of questions
— is on the values that such a function g provides as an approximation to the true function f .
Discrete f -approximators. In the most basic type of f -approximator, each cell Ci is a union
of rows of the table defining f . Thus, since each cell in an f -approximator receives a value equal
to the average value of f over all applicants in the cell, we assign cell Ci the value θ(Ci ) = f |Ci .
General f -approximators. A fully general f -approximator can do more than this; it can divide
up individual rows so that subsets of the row get placed in different cells. We can imagine this
taking place through randomization, or through some other way of splitting the applicants in a
single row. For such a function g, we can still think of it as consisting of cells C1 , C2 , . . . , Cd , but
these cells now have continuous descriptions. Thus, g is described by a collection of non-negative,
non-zero vectors φ1 , φ2 , ..., φd , with each φi indexed by all the rows, and φi (x) specifying the total
measure ofP
row x that is assigned to the cell Ci in g’s partition of the space. Thus we have the
constraint di=1 φi (x) = µ(x), specifying that each row has been partitioned. We P
define µ(Ci ) to
be the total measure of all the fractions of rows assigned to Ci ; that is, µ(Ci ) = x φi (x). The
average value of the applicants in cell Ci is given by
P
φi (x)f (x)
θ(Ci ) = x
.
µ(Ci )
An easy way to think about the approximator g is that it assigns a value to an applicant with
extended feature vector x by mapping the applicant to cell Ci with probability φi (x)/µ(x), and
then assigning them the value θ(Ci ).
To prevent the space of f -approximators from containing functions with arbitrarily long descriptions, we will assume that there is an absolute bound B on the number of cells allowed in an
f -approximator. (We will suppose that B ≥ 2k+1 so that a discrete f -approximator that puts each
row of f in a separate cell is allowed.)
It will also be useful to talk about the fraction of applicants in cell Ci that belong to each of
the groups A and D. We write σ(Ci ) for the fraction of applicants in Ci belonging to group D;
that is,
P
(x,D) φi (x, D)
.
σ(Ci ) =
µ(Ci )
2
We will allow distinct cells to have the same value: θ(Ci ) = θ(Cj ). In an alternate formulation of the model, we
could require that all cells have distinct values; the main results would be essentially the same in this case, although
certain fine-grained details of the model’s behavior would change.

9

Note that our more basic class of discrete f -approximators g that just partition rows can be
viewed as corresponding to a subset of this general class of f -approximators as follows: for all x, we
simply require that exactly one of the values φi (x) is non-zero. In this case, note that θ(C) = f |C
by definition.
Our notion of an approximator includes functions that use group membership; that is, two
applicants who differ only in group membership (i.e. from respective rows (x, A) and (x, D) for
some x) can be placed in different cells. There are several reasons we allow this in our model.
First, it is important to remember that by construction we have assumed the true function f does
not depend on group membership: f (x, A) = f (x, D) for all x. As a result, if we allowed a fully
complex model that used the true values f (x, γ) for all applicants, there would be no efficiency
gains from using group membership. Consequently, the main use of group membership in the
constructions we consider is in fact to remediate the negative effects on group D incurred through
simplification. Second, in many of our motivating applications, the distinction between groups A
and D does not correspond to a variable whose use is legally prohibited; instead its use may be
part of standard practice for alleviating disadvantage. For example, the distinction between A
and D may correspond to geographic disadvantage, or disadvantage based on some aspects of past
educational or employment history, all of which are dimensions that are actively taken into account
in admission-style decisions. Finally, even in cases where group membership corresponds to a legally
prohibited variable, these prohibitions themselves are the result of regulations that were put in place
at least in part through analysis that clarified the costs and benefits of allowing the use of group
membership. As a result, to inform such decisions, it is standard to adopt an analytical framework
that allows for the use of such variables ex ante, and to then use the framework to understand the
consequences of prohibiting these variables. In the present case, our analysis will show how the use
of these variables may be necessary to reduce harms incurred through the application of simplified
models.
At various points, it will also be useful to talk about approximators that do not use group
membership. We formalize this as follows.
(3.3) We call a discrete f -approximator group-agnostic if for every feature vector x = (xh1i , . . . , xhki ),
the two rows (x, A) and (x, D) belong to the same cell.
Non-triviality and simplicity. We say that a cell C of an f -approximator is non-trivial if it
contains positive measure from rows x, x0 for which f (x) 6= f (x0 ); and we say that an f -approximator
itself is non-trivial if it has a non-trivial cell.
Any f -approximator that is discrete and non-trivial already represents a form of simplification
of f , in that it is grouping together applicants with different f -values as part of a single larger cell.
However, this is a very weak type of simplification, in that the resulting f -approximator can still
be relatively lacking in structure. We therefore focus in much of our analysis on a structured form
of simplicity that abstracts a key property of most approaches to simplifying f .
Our core definition of simplicity is motivated by considering what are arguably the most natural
ways to construct collections of discrete, non-trivial f -approximators, as special cases of one (or
both) of the following definitions.
• Variable selection. First, we could partition the rows into cells by projecting out certain
variables among xh1i , . . . , xhki , xhk+1i (where again xhk+1i = γ is the group membership variable). That is, for a set of indices R ⊆ {1, 2, . . . , k + 1}, we declare two rows xi and xj to

10

h`i

h`i

be equivalent if xi = xj for all ` ∈ R. The cells C1 , . . . , Cd are then just the equivalence
classes of rows under this equivalence relation.
• Decision tree. Second, we could construct a partition of the rows using a decision tree whose
internal nodes consist of tests of the form xh`i = b for ` ∈ {1, 2, . . . , k + 1}, and b ∈ {0, 1}.
(For xhk+1i we can use 0 to denote A and 1 to denote D in this structure.) An applicant
is mapped to a leaf of the tree using a standard procedure for decision trees, in which they
start at the root and then proceed down the tree according to the outcome of the tests at
the internal nodes. We declare two rows x0 and x0 to be equivalent if they are mapped to the
same leaf node of the decision tree, and again define the cells C1 , . . . , Cd to be the equivalence
classes of rows under this relation.
We say that a cell Ci is a cube if it consists of all feature vectors obtained by specifying the values
of certain variables and leaving the other variables unspecified. That is, for some set of indices
R ⊆ {1, 2, . . . , k + 1}, and a fixed value bi ∈ {0, 1} for each i ∈ R, the cell Ci consists of all vectors
(xh1i , . . . , xhk+1i ) for which xhii = bi for each i ∈ R. We observe the following.
(3.4) For any discrete f -approximator constructed using either variable selection or a decision
tree, each of its cells is a cube.
We abstract these constructions into the notion of a simple f -approximator.
(3.5)
cube.

A simple f -approximator is a non-trivial discrete f -approximator for which each cell is a

This is the basic definition of simplicity that we use in what follows. If an f -approximator
doesn’t satisfy this definition, it must be that at least one of its cells is obtained by gluing together
sets of rows that don’t naturally align along dimensions in this sense; this is the respect in which it
is not simple in our framework. At the end of this section, we will describe a generalization of this
definition that abstracts beyond the setting of Boolean functions, and contains (3.5) as a special
case.
We note that while decision trees provide a large, natural collection of instances of simple f approximators, there are still larger collections of simple f -approximators that do not arise from the
decision-tree construction described above. To suggest how such further simple f -approximators
can be obtained, consider a partition of the eight rows associated with the three variables xh1i , xh2i ,
and the group membership variable γ: we define the cells to be
C1 = {(1, 1, D)}; C2 = {(1, 1, A), (0, 1, A)}; C3 = {(0, 1, D), (0, 0, D)};
C4 = {(1, 0, A), (1, 0, D)}; C5 = {(0, 0, A)}.
It is easy to verify that this f -approximator is simple, since each of its five cells is a cube. But it
cannot arise from the decision-tree construction described above because no variable could be used
for the test at the root of the tree: C2 contains rows with both values of xh1i , while C3 contains
rows with both values of xh2i and C4 contains rows with both values of γ.
Our definition of simple approximators is not only motivated by the natural generalization of
methods including variable selection and decision trees; it also draws on basic definitions from
behavioral science. To the extent that the cells in an approximator represent the categories or
groupings of applicants that will be used by human decision-makers in interpreting it, requiring that
cells be cubes is consistent with two fundamental ideas in psychology. First, people mentally hold
11

knowledge in categories where like objects are grouped together; such categories can be understood
as specifying some of the features but leaving others unspecified [31, 32, 35]. (For example, when
we think of “red cars,” we have specified two values — that the object is a car and the color is
red — but have left unspecified the age, size, manufacturer, and other features.) This process of
specifying some values and leaving others unspecified is precisely our definition of a cube. Second,
the definition of a cube can be viewed equivalently as saying that each cell is defined by a conjunction
of conditions of the form xi = bi . Mental model theory from psychology emphasizes how conjunctive
inferences such as these are easier than disjunctive inferences because they require only one mental
model as opposed to a collection of distinct models [16]. (For example, “red cars” is a cognitively
more natural concept for human beings than the logically analogous concept, “objects that are red
or are cars.”)

3.3

Admission Rules

Any f -approximator g creates an admission rule for applicants: we sort all applicants by their value
determined by g, and we admit them in this order, up to a specified admission rate r ∈ (0, 1] that
sets the fraction of the population we wish to admit. Let Ag (r) be the set of all applicants who are
admitted under the rule that sorts applicants according to g and then admits the top r fraction
under this order.
We can think about the sets Ag (r) in terms of the ordering of the cells of g as C1 , C2 . . . , Cd
arranged in decreasing order of θ(Ci ). Let rj be the measure of the first j cells in order, with
hgi
r0 = 0. (We will sometimes write rj as rj when we need to emphasize the dependence on g.)
Then for any admission rate r, the set of admitted applicants Ag (r) will consist of everyone in the
cells Cj for which rj ≤ r, along with a (possibly empty) portion of the next cell. We can write this
as follows: if j(r) is the unique index j such that rj−1 ≤ r < rj , then the set Ag (r) consists of all
the applicants in the cells C1 , C2 , . . . , Cj(r)−1 , together with a proper subset of Cj(r) .
Efficiency and equity. Two key parameters of an admission rule are (i) its efficiency, equal to
the average f -value of the admitted applicants; and (ii) its equity, equal to the fraction of admitted
applicants who belong to group D. Each of these is a function of r: the efficiency, denoted Vg (r), is
a decreasing function of r (since we admit applicants in decreasing order of cell value), whereas the
equity, denoted Wg (r), can have a more complicated dependence on r (since successive cells may
have a higher or lower representation of applicants from group D). We think of society’s preferences
as (at least weakly) favoring larger values for these two quantities (consistent with a social welfare
approach to fairness and equity [24]), but we will not impose any additional assumptions on how
efficiency and equity are incorporated into these preferences.
We can write these efficiency and equity functions as follows. First, let vg (r) be the f -value of
the marginal applicant admitted when the admission rate is r; that is, vg (r) = θ(Cj(r) ). Similarly,
let wg (r) be the probability that the marginal applicant admitted belongs to group D; that is,
wg (r) = σ(Cj(r) ). Each of these functions is constant on the intervals of r when it is filling in the
applicants from a fixed Cj ; that is, it is constant on each interval of the form (rj−1 , rj ), and it has
a possible point of discontinuity at points of the form rj .
We can then write the efficiency and the equity simply as the averages of these functions vg (·)
and wg (·) respectively:
Z
1 r
Vg (r) =
vg (t) dt
r 0
12

and
Wg (r) =

1
r

Z

r

wg (t) dt.
0

Note that even though vg (·) and wg (·) have points of discontinuity, the efficiency and equity functions are continuous.

3.4

Improvability and Maximality

Suppose we prefer admission rules with higher efficiency and higher equity, and we are currently
using an f -approximator g with associated admission rule Ag (·). What would it mean to improve
on this admission rule? It would mean finding another f -approximator h whose admission rule
Ah (·) produced efficiency and equity that were at least as good for every admission rate r, and
strictly better for at least one admission rate r∗ . In this case, from the perspective of efficiency and
equity, there would be no reason not to use h in place of g, since h is always at least as good, and
sometimes better.
Formally, we will say that h weakly improves on g, written h  g, if Vh (r) ≥ Vg (r) and
Wh (r) ≥ Wg (r) for all r ∈ (0, 1]. We say that h strictly improves on g, written h  g, if h
weakly improves on g, and there exists an r∗ ∈ (0, 1) for which we have both Vh (r∗ ) > Vg (r∗ ) and
Wh (r∗ ) > Wg (r∗ ). (Viewing things from the other direction of the comparison, we will write g  h
if h  g, and g ≺ h if h  g.)
It can be directly verified from the definitions that the following transitive properties hold.
(3.6) If g0 , g1 , and g2 are f -approximators such that g2  g1 and g1  g0 , then g2  g0 . If
additionally g2  g1 or g1  g0 , then g2  g0 .
We say that an f -approximator g is strictly improvable if there is an f -approximator h that
strictly improves on it. For the reasons discussed above, it would be natural to favor f -approximators
that are not strictly improvable: we say that an f -approximator g is maximal if there is no f approximator h that strictly improves on it.
The set of maximal f -approximators is in general quite rich in structure, but we can easily pin
down perhaps the most natural class of examples: if we recall that a trivial approximator is one that
never combines applicants of distinct f -values into the same cell, then it is straightforward to verify
that every trivial f -approximator g is maximal, simply because there cannot be any f -approximator
h and admission rate r∗ for which Vh (r∗ ) > Vg (r∗ ).
(3.7)

Every trivial f -approximator is maximal.

(3.7) establishes the existence of maximal f -approximators, but we can say more about them
via the following fact, which establishes that every f -approximator has at least one maximal approximator “above” it.
(3.8)
it.

For every f -approximator g, there exists a maximal f -approximator h that weakly improves

Since the proof of (3.8) is fairly technical, and the methods used are not needed in what follows,
we defer the proof to the appendix.
Improvability in Efficiency and Equity. At various points, it will be useful to talk about
pairs of approximators that satisfy the definition of strict improvability only for efficiency, or only
for equity.

13

Thus, for two f -approximators g and h, will say that h strictly improves g in efficiency if at
every admission rate r, the average f -value of the applicants admitted using h is at least as high
as the average f -value of the applicants admitted using g, and it is strictly higher for at least
one value of r. We will write this as h v g or equivalently g ≺v h; in the notation developed
above, it means that Vh (r) ≥ Vg (r) for all r ∈ (0, 1], and Vh (r) > Vg (r) for at least one value of r.
Correspondingly, we will say that h strictly improves g in equity, written h w g or equivalently
g ≺w h, if Wh (r) ≥ Wg (r) for all r ∈ (0, 1], and Wh (r) > Wg (r) for at least one value of r. We
observe that the analogue of our fact about transitivity, (3.6), holds for both v and w .

3.5

Main Results

Given the model and definitions developed thus far, it is easy to state the basic forms of our two
main results. We let f be an arbitrary function over a set of extended feature vectors for which the
disadvantage condition (3.1) and genericity assumption (3.2) hold.
First Result: Simple Functions are Improvable.
result.
(3.9)

In Section 5, we will prove the following

Every simple f -approximator is strictly improvable.

This result expresses the crux of the tension between simplicity and equity — for every admission
rule based on a simple f -approximator, we can find another admission rule that is at least as good for
every admission rate, and which for some admission rates strictly improves on it in both efficiency
and equity. Thus, whatever one’s preferences are for efficiency and equity, this alternate admission
rule should be favored on these two grounds.
We will prove this result in Section 5. To get a sense for one of the central ideas in the proof, it
is useful to consider a simple illustrative special case of the result: if g is the f -approximator that
puts all applicants into a single cell C, how do we strictly improve it?
We can construct a strict improvement on g as follows. First, for the approximator g, note
that the function Vg (r) is a constant, independent of r and equal to the average f -value over the
full population of applicants. The function Wg (r) is also a constant, equal to the fraction of Dapplicants in the full population. We construct a strict improvement on g by first finding a row
associated with group D that has an above-average f -value (such a row exists since f is not a
constant function and doesn’t depend on group membership) and pulling this row into a separate
cell that we can admit first. Specifically, let x be the feature vector for which f (x, D) is maximum,
and consider the approximator h consisting of two cells: C1 containing just the row (x, D), and
C2 containing all other rows. The function Vh (r) is equal to f (x, D) for r ≤ µ(x, D), and then it
decreases linearly to Vg (1). The function Wh (r) is equal to 1 for r ≤ µ(x, D), and then it decreases
linearly to Wg (1). It follows that h strictly improves on g.
In the full proof of the result, we will need several different strategies for pulling rows out of a cell
so as to produce an improvement. In addition to pulling out rows of high f -value associated with
group D, we will also sometimes need to pull out rows of low f -value associated with group A; and
sometimes we will need to pull out just a fraction of a row, producing a non-discrete approximator.
The crux of the proof will be to show that some such operation is always possible for a simple
approximator.

14

Second Result: Simplicity Can Transform Disadvantage into Bias. The second of our
main results concerns group-agnostic approximators. Suppose that g is a group-agnostic f -approximator,
so that rows of the form (x, A) and (x, D) always appear together in the same cell. Perhaps the
most basic example of such a structure is the unique f -approximator g ◦ that is both group-agnostic
and trivial: it consists of 2k cells, each consisting of the two rows {(x, A), (x, D)} for distinct feature
vectors x. Since f (x, A) = f (x, D) for all feature vectors x, this approximator g ◦ has the property
that it would not be strictly improved in efficiency if we were to split each cell {(x, A), (x, D)} into
two distinct cells, one with each row, since these two new smaller cells would each have the same
value.
Now, however, consider any group-agnostic f -approximator g that is non-trivial, in that it
has cells containing rows of different f -values. (Recall that group-agnostic approximators are by
definition discrete, in that each row is assigned in its entirety to a cell rather than being split over
multiple cells.) Let χ(g) be the f -approximator that we obtain from g by splitting each of its cells
Ci into two sets according to group membership — that is, into the two cells {(x, A) : (x, A) ∈ Ci }
and {(x, D) : (x, D) ∈ Ci } — and then merging cells of the same θ-value.
In Section 6, we will show that as long as g is non-trivial, this operation strictly improves
efficiency, and strictly worsens equity:
(3.10) If g is any non-trivial group-agnostic f -approximator, then χ(g) strictly improves g in
efficiency, and g strictly improves χ(g) in equity.
This result highlights a key potential concern that arises when we approximate a productivity function f in the presence of disadvantage. Consider a decision-maker who is interested in
maximizing efficiency, and does not have preferences about equity. When they are using the true
f -values for each applicant, as g ◦ does above, there is no incentive for this decision-maker to take
group membership into account. But as soon as they are using any non-trivial group-agnostic
approximator g, there becomes an incentive to incorporate knowledge of group membership, since
splitting the cells of g according to group membership in order to produce χ(g) will create a strict
improvement in efficiency. However, this operation comes at a cost to the disadvantaged group D,
since g strictly improves χ(g) in equity.
Thus, any non-trivial group-agnostic approximation to f is effectively transforming disadvantage
into bias: where the decision-maker was initially indifferent to group membership, the process of
suppressing information so as to approximate f created an incentive to use a rule that is explicitly
biased in using group membership as part of the decision.
Comparing Different Forms of Simplicity. It is useful to observe that our two results (3.9)
and (3.10) are both based on simplifying the underlying function f , but in different ways. The first
is concerned with approximators that are simple in the sense of (3.5), that each cell is obtained
by fixing the values of certain variables xhii and leaving the others unrestricted. The second is
concerned with approximators that are group-agnostic, in the sense that rows of the form (x, A) and
(x, D) always go into the same cell; but it applies to any non-trivial group-agnostic approximator.
Before proceeding to some illustrative examples and to the proofs of these results, we first cast
them in a more general form.

15

3.6

A More General Formulation

It turns out that the proof technique we use for our main results can be used to establish a
corresponding pair of statements in a more general model. It is worth spelling out this more
general version, since it makes clear that our results do not depend on a model in which the feature
vectors must be comprised of k Boolean coordinates; in fact, all that matters is that there is an
arbitrary finite set of feature vectors.
We define this more general formulation as follows. Suppose that each individual is described by
one of n possible feature vectors, labeled x1 , x2 , . . . , xn , along with a group membership variable γ
which, as before, can take the value A or D. As before, the fraction of the population described by
the extended feature vector (xi , γ) is given by µ(xi , γ); the productivity of an individual described
by (xi , γ) is given by a function f (xi , γ); and group membership has no effect on f once we know
the value of xi : that is, f (xi , A) = f (xi , D), and we will refer to both as f (xi ). We will continue to
refer to each extended feature vector (x, γ) as a row x (of the look-up table defining f ), and assume
that f (xi , γ) 6= f (xj , γ 0 ) for different feature vectors xi , xj ; for convenience we will index the feature
vectors x1 , x2 , . . . , xn , so that f (xj ) > f (xi ) when j > i. The disadvantage condition also remains
essentially the same as before: if xi and xj are feature vectors such that f (xj ) > f (xi ), then
µ(xj , A)
µ(xi , A)
>
.
µ(xj , D)
µ(xi , D)
To see that our original Boolean model is a special case of this more general one, simply set
n = 2k and let x1 , x2 , . . . , xn be the n possible vectors consisting of k Boolean values, sorted
h1i
hki
in increasing order of f -value. (That is, each feature vector xi has the form (xi , . . . , xi ) for
h1i
hki
Boolean variables xi , . . . , xi ). The remainder of the model is formulated in exactly the same
way as before, with one exception: the definition of a simple f -approximator was expressed in
terms of the Boolean coordinates of the feature vectors (as part of the definition of a cube), and so
we need to generalize this definition to our new setting, resulting in a class of approximators that
contains more than just simple ones.
Graded approximators. To motivate our generalization of simple approximators, which we
will refer to as graded approximators, we begin with some notation. For a cell Ci in a discrete
hAi
f -approximator, let Ci denote the set of feature vectors x such that (x, A) is a row of Ci , and let
hDi
Ci denote the set of feature vectors x such that (x, D) is a row of Ci . We observe that a simple
hAi
hDi
f -approximator has the property that for every cell Ci , either one of Ci or Ci is empty, or else
hAi
hDi
hAi
hDi
hDi
hAi
Ci = Ci . Thus we have Ci ⊆ Ci or Ci ⊆ Ci for all cells.
We take this condition as the basis for our definition of graded approximators.
(3.11) A graded f -approximator is a non-trivial discrete f -approximator whose cells C1 , C2 , . . . , Cd
hAi
hDi
hDi
hAi
satisfy Ci ⊆ Ci
or Ci
⊆ Ci for each i. In the special case when the feature vectors are
comprised of Boolean coordinates, all simple f -approximators are graded.
The more general formulation of our first result applies to graded approximators. Since all
simple appoximators are graded, this more general version thus extends the earlier formulation
(3.9). We state the result as follows, given an arbitrary function f for which the disadvantage
condition and genericity assumption (the analogues of (3.1) and (3.2)) hold.
(3.12)

Every graded f -approximator is strictly improvable.
16

xh1i
1
1
1
1
0
0
0
0

xh2i
1
1
0
0
1
1
0
0

γ
D
A
D
A
D
A
D
A

f
1
1
y10
y10
y01
y01
0
0

µ
q1 q20 /2
p1 p2 /2
q1 p02 /2
p1 q2 /2
p1 q20 /2
q1 p2 /2
p1 p02 /2
q1 q2 /2

Figure 1: An example of a function with two Boolean variables and a group membership variable.

For the second result, we note that the definition of a group-agnostic approximator remains the
same in this more general model — that for every feature vector xi , the two rows (xi , A) and (xi , D)
should belong to the same cell — and so our second result continues to have the same statement
as in (3.10). It is also worth observing that every group-agnostic f -approximator in our more
hAi
hDi
general model is graded in the sense of (3.11), since Ci = Ci for every cell in a group-agnostic
approximator by definition.

4

Examples and Basic Phenomena

To make the model and definitions more concrete, it is useful to work out an extended example; in
the process we will also identify some of the model’s basic phenomena. For purposes of this example,
we will make use of the initial Boolean formulation of our model, rather than the generalization to
graded approximators.
In our example, there are two Boolean variables xh1i and xh2i , along with the group membership
γ. Applicants have much higher productivity when xh1i = xh2i = 1 than for any other setting of the
variables; we define f (1, 1) = 1 and f (0, 0) = 0; and we define f (1, 0) = y10 and f (0, 1) = y01 for
very small numbers y10 > y01 > 0. By choosing y10 and y01 appropriately (for example, uniformly
at random from a small interval just above 0) it is easy to ensure that the genericity condition
holds.
Half the population belong to the advantaged group A and the other half belongs to the disadvantaged group D. To define the distribution of values in each group, we fix numbers p1 > p2
between 0 and 1, close enough to 1 that p1 p2 > 21 . For compactness in notation, we will write qi for
1−pi . In the advantaged group A, each applicant has xi = 1 independently (for i = 1, 2) with probability pi , and xi = 0 otherwise. In the disadvantaged group D, the situation is (approximately)
reversed. Each applicant in group D has x1 = 1 independently with probability q1 = 1 − p1 , and
x1 = 0 otherwise. To ensure the genericity condition, we choose a value p02 very slightly above p2
(but smaller than p1 ), and define q20 = 1 − p02 ; each applicant in group D has x2 = 1 independently
with probability q20 , and x2 = 0 otherwise. The full function f is shown in Figure 1; it is easy to
verify that the disadvantage condition (3.1) holds for this example.

17

4.1

Two Trivial Approximators

Before discussing simple approximators, it is worth briefly remarking on two natural trivial f approximators. The first, which we will denote g ∗ , puts each row into a single cell, and it sorts
these eight cells in the order given by reading the table in Figure 1 from top to bottom. The second,
g ◦ , which was discussed in Section 3.5, groups together pairs of rows that differ only in the group
membership variable γ: thus it puts the first and second row into a cell C1 ; then the third and
fourth into a cell C2 ; and so on, producing four cells.
Even the comparison between these two trivial approximators highlights an important aspect of
our definitions. g ∗ and g ◦ have the same efficiency functions Vg∗ (·) and Vg◦ (·). The equity function
of g ∗ , on the other hand, is clearly preferable to the equity function of g ◦ : we have Wg∗ (r) ≥ Wg◦ (r)
for all r, and Wg∗ (r) > Wg◦ (r) for a subset of values of r. It is not the case that g ∗ strictly improves
on g ◦ according to our definitions, however, since that would require the existence of an r for which
Vg∗ (r) > Vg◦ (r) and Wg∗ (r) > Wg◦ (r). This is clearly not possible, since Vg∗ (·) and Vg◦ (·) are
the same function. In fact, both g ∗ and g ◦ are maximal. The issue is that our definition of strict
improvement sets a very strong standard: one admission rule strictly improves another if and only
if it is better for a decision-maker who cares only about efficiency, or only about equity, or about
any combination of the two. And from the point of view of a decision-maker who cares only about
efficiency, g ∗ is not strictly better than g ◦ .
This is a crucial point; we have chosen a deliberately strong standard for the definition of strict
improvement (and a weak definition of maximality) because it allows us to state our result (3.9)
in a correspondingly strong way: even though it requires a lot to assert that an approximator h
strictly improves an approximator g, it is nevertheless the case that every simple approximator is
strictly improvable.

4.2

Improving a Simple Approximator

Now, let’s consider a natural example of a simple f -approximator, and see how it can be strictly
improved. The approximator we consider is g1 , which creates two cells: C1 , consisting of all
applicants for whom xh1i = 1, and C2 , consisting of all applicants for whom xh1i = 0. Intuitively,
this corresponds to projecting the applicants onto just the variable xh1i , ignoring the values of xh2i
and the group membership γ.
For g1 , we have µ(C1 ) = p1 /2 + q1 /2 = 1/2, and µ(C2 ) = 1/2 as well. In this first cell C1 , the
fraction of D-applicants is
q1 /2
= q1 ,
p1 /2 + q1 /2
and so Wg1 (r) = q1 for all r ≤ 1/2. The average f -value of the applicants in C1 , working directly
from the definition, is p1 p2 + q1 q20 + y10 (p1 q2 + q1 p02 ), which is close to p1 p2 + q1 q20 since y10 is very
small. This is the value of Vg1 (r) for all r ≤ 1/2.
Now, let’s look for a function that strictly improves g1 . A natural first candidate to consider
is g ∗ : its efficiency cannot be improved at any admission rate r since it orders all applicants in
decreasing order of f -value; and subject to this (i.e. as a tie-breaker) it puts D-applicants ahead of
A-applicants. It turns out, though, that there are values of the admission rate r for which g1 has
better equity than g ∗ . In particular, consider r∗ = (p1 p2 + q1 q20 )/2, when the set Ag∗ (r∗ ) admitted

18

Simple Approximator
rows for D

Improvement

cells

rows for A

rows for D

cells

rows for A

(1,1)

(1,1)

(1,1,D)

(1,1)

(1,0)

(1,0)

(1,0)

(0,1)

(0,1)

(0,1)

(1,1)
(1,1)
(1,0)

(0,1)
(0,1)

(1,1,A)
(1,0)

(1,0)

(0,1)
(1,1)
(1,0)

(0,0)

(0,0)

(0,0)

(0,0)

Figure 2: On the left, we have a depiction of the approximator g1 , which simply groups applicants by
the value of xh1i : the blue and red circles represent the rows associated with D and A respectively,
and they are linked to ovals representing the cells that contain them. We can improve both the
efficiency and the equity of g1 if we use the construction on the right, creating a new cell that pulls
out the row (1, 1, D) — containing those applicants from group D with xh1i = xh2i = 1 — and
ranking it separately.

according to g ∗ is precisely those applicants with xh1i = xh2i = 1. For this value of r∗ , we have
Wg∗ (r∗ ) =

q1 q20
.
p1 p2 + q1 q20

But since r∗ = (p1 p2 + q1 q20 )/2 < (p1 + q1 )(p2 + q20 )/2 < (p1 + q1 )(p2 + q2 )/2 = 1/2, we have
Wg1 (r∗ ) = q1 =

q1 q20
q1 q20
>
= Wg∗ (r∗ ),
p1 q20 + q1 q20
p1 p2 + q1 q20

and therefore g ∗ does not strictly improve on g1 .
Arguably, this calculation implicitly connects to the qualitative intuition that simpler rules may
be fairer in general: since the distributions of both xh1i and xh2i confer disadvantage on group D,
by using only one of them rather than both (thus using g1 instead g ∗ ) we give up some efficiency
but we are rewarded by improving equity at a crucial value of the admission rate: specifically, the
rate r∗ corresponding to the fraction of “top applicants” (of f -value equal to 1) in the population.
But this intuition is misleading, because in fact there are approximators that improve on g1 in
both efficiency and equity; it’s just that g ∗ isn’t one of them. An approximator that we can use is
h, which starts from g1 and then splits the cell C1 into two cells: C10 , consisting of applicants from
19

xh1i
1
0

xh2i
any
any

γ
any
any

g1
p1 p2 + q1 q20 + y10 (p1 q2 + q1 p02 )
y01 (p1 q20 + q1 p2 )

µ
1/2
1/2

(a) Approximator g1 using only xh1i

xh1i
1
1
0
0

xh2i
any
any
any
any

γ
A
D
A
D

χ(g1 )
p2 + y10 q2
q20 + y10 p02
y01 p2
y01 q20

µ
p1 /2
q1 /2
q1 /2
p1 /2

(b) Approximator χ(g1 ) using xh1i and γ

Figure 3: The f -approximator g1 has only two cells, based on the value of xh1i . When we split each
of these cells by using the value of the group membership variable γ as well, we end up with an
f -approximator χ(g1 ) that is strictly better in efficiency and strictly worse in equity. Thus, for a
decision-maker interested in maximizing efficiency, the suppression of xh2i leads to an incentive to
consult the value of group membership, in a way that reduces equity for group D.

row (1, 1, D), and C100 , consisting of applicants from the three rows (1, 1, A), (1, 0, A), and (1, 0, D).
The approximator h thus has the three cells C10 , C100 , C2 , in this order. We can now check that h is
at least as good as g1 at every admission rate r, since it is admitting the applicants of cell C1 in a
subdivided order — everyone in C10 followed by everyone in C100 — and the applicants in C10 have
a higher average f -value than the applicants of C1 , and all of them belong to group D. Moreover,
this means that when r = µ(C10 ), we have Vh (r) > Vg1 (r) and Wh (r) > Wg1 (r), and hence h strictly
improves g1 .
Figure 2 shows schematically how we produce h from g1 . Initially, g1 groups all the rows with
h1i
x = 1 into one cell, and all the rows with xh1i = 0 into another. We then produce h by pulling
the row (1, 1, D) out of this first cell and turning it into a cell on its own, with both a higher average
f -value and a positive contribution to the equity.
This example gives a specific instance of the general construction that we will use in proving
our first main result (3.12): breaking apart a non-trivial cell so as to admit a subset with both a
higher average f -value and a higher representation of D-applicants. This construction also connects
directly to both our earlier discussion of improving simple approximators, and to the line of intuition
expressed in the introduction — that simplifying by suppressing variables can prevent the strongest
disadvantaged applicants from demonstrating their strength.

4.3

Adding Group Membership to an Approximator

Because the approximator g1 is group-agnostic, we can also use it to provide an example of the
effect we see when we move from a group-agnostic approximator g to the version χ(g) in which we
split each of g’s cells using group membership.
Specifically, consider the cells of g1 , denoted C1 and C2 in the previous subsection. C1 groups
together the four rows in which xh1i = 1, and C2 groups together the four rows in which xh1i = 0.
Now, suppose that we split C1 into two cells: C10 consisting of the two rows in which xh1i = 1

20

Group-Agnostic
rows for D

(1,1)

cells

Group-Aware
rows for A

rows for D

(1,1)

(1,1)

(1,1)
(1,1)
(1,0)
(1,0)
(1,0)

rows for A
cells

(1,1)
(1,0)
(1,0)

(1,1)

(1,1)
(1,0)
(1,0)

(1,0)
Disadvantaged have
more (1,0)

(0,1)

(0,1)

(0,1)

(0,0)

(0,0)

(0,1)
(0,1)
(0,1)
(0,0)
(0,0)

(0,1)
(0,1) (0,0)
(0,0)
Disadvantaged have
more (0,0)

(0,1)

(0,0)

Figure 4: As in Figure 2, the approximator on the left is g1 , which groups applicants by the value
of xh1i . If we split each of the two cells using group membership, we get the approximator χ(g1 ) on
the right, with four cells in total: two associated with group A and two associated with group D.
In χ(g1 ), the cells associated with A have moved slightly upward in value, and the cells associated
with D have moved slightly downward in value. As a result, this new approximator χ(g1 ) is more
efficient but less equitable than the original group-agnostic approximator g1 .

and γ = A, and C100 consisting of the two rows in which xh1i = 1 and γ = D. Working from the
definitions, the average f -value of an applicant in C10 is p2 + y10 q2 , while the average f -value of an
applicant in C100 is q20 + y10 p02 . Similarly, if we split C2 into cells C20 with xh1i = 1 and γ = A, and
C200 with xh1i = 1 and γ = D, then the average f -value of an applicant in C20 is y01 p2 , while the
average f -value of an applicant in C200 is y01 q20 .
The pair of tables in Figure 3 provides one way of summarizing these calculations: each row
represents a cell in which certain variables are fixed and others are set to “any,” meaning that
the cell averages over rows with any value allowed for these variables. To go from g1 to χ(g1 ), we
convert the first row in the first table into the top two rows in the second table, and we convert
the second row in the first table into the bottom two rows in the second table.
We have the sequence of inequalities
θ(C10 ) > θ(C1 ) > θ(C100 ) > θ(C20 ) > θ(C2 ) > θ(C200 ),
reflecting the fact that using group membership in conjunction with xh1i results in a partition of
each cell into a subset with higher average f -value and a subset with lower average f -value. Since
χ(g1 ) consists of the cells C10 , C100 , C20 , C200 , it strictly improves g1 in efficiency. But since χ(g) places
rows associated with group A ahead of the corresponding rows associated with group D, it follows
21

that g strictly improves χ(g) in equity.
Figure 4 provides another way to depict the transformation from g1 to χ(g1 ): when we split the
cells of g1 using group membership, the cells associated with group A move slightly upward and the
cells associated with group D move slightly downward, producing both the increase in efficiency
and the reduction in equity.
Thus, for a decision-maker who wants to maximize efficiency, the f -approximator g1 creates
an incentive to consult the value of γ encoding group membership, since doing so leads to a strict
improvement in efficiency. The resulting rule χ(g1 ), however, is explicitly biased against applicants
from group D, in that it uses group membership information and results in reduced equity for
group D. This effect wouldn’t have happened had we started from the f -approximator g ◦ that
uses the values of both xh1i and xh2i ; in that case, efficiency would not be improved by using group
membership information. It is by suppressing information about the value of xh2i that g1 creates
an incentive to incorporate group membership.

5

Proof of First Result: Simple Functions are Improvable

In this section, we prove our first main result in its general form, (3.12). The basic strategy will be
an extension of the idea used in the discussion after the statement of (3.9) and in the example from
Section 4.2: given a simple (or graded) f -approximator g, we will show how to break up one or
more of its cells, changing the order in which rows are admitted, so that the efficiency and equity
don’t decrease, and for some admission rate we are admitting applicants of higher average f -value
and with a greater fraction of D-applicants.
It will turn out that the most challenging case is when we have an f -approximator g in which
each non-trivial cell consists entirely of rows associated with A or entirely of rows associated with
D. We will call such an approximator separable (since its non-trivial cells separate the two groups
completely); it is easy to verify from the definition of graded approximators in (3.11) that every separable approximator is graded. For this case, we will need to first prove a preliminary combinatorial
lemma, which in turn draws on a consequence of the disadvantage condition.
We will work in the general model, where we have an arbitrary set of feature vectors {x1 , x2 , . . . , xn },
indexed so that f (xi ) < f (xj ) for i < j; this results in a set of 2n rows of the form (xi , γ) for a
group membership variable γ. We will use yi to denote f (xi ), so the set of possible f -values is
{y1 , . . . , yn }.

5.1

A Consequence of the Disadvantage Condition

It is not hard to show that the disadvantage condition implies that the average f -value over the
A-applicants is higher than the average f -value over the D-applicants. But we would like to
establish something stronger, as follows. For a set of feature vectors S ⊆ {x1 , x2 , . . . , xn }, let
SA = {(xi , A) : xi ∈ S} and SD = {(xi , D) : xi ∈ S}. For a set S, we let |S| denote the number of
elements it has. We will show
(5.1)

For any set of feature vectors S ⊆ {x1 , x2 , . . . , xn } with |S| > 1, we have f |SA > f |SD .

Note that for the case when |S| = 1, we must have f |SA = f |SD because in this case S consists
of just a single feature xi , and by assumption f (xi , A) = f (xi , D) for all i.
To prove (5.1), and some of the subsequent results in this section, there is a useful way to think
about averages over sets of rows in terms of random variables. We define the random variable YA to
22

be the f -value of an applicant drawn uniformly at random from group A, and the random variable
YD to be the f -value of an applicant drawn uniformly at random from group D. Both of these random variables take values in the set {y1P
, . . . , yn }, but they have different distributions
Pover this set;
in particular, Pr [YA = yj ] = µ(xj , A)/ ni=1 µ(xi , A) and Pr [YD = yj ] = µ(xj , D)/ ni=1 µ(xi , D).
We will use αj to denote Pr [YA = yj ] and δj to denote Pr [YD = yj ]. Note that the disadvantage
condition (3.1) implies that the sequence of ratios αi /δi is strictly increasing in i: if j > i, then
αj /δj > αi /δi .
In the language of random variables, the disadvantage condition thus asserts that the random
variable YA exhibits likelihood-ratio dominance with respect to the random variable YD [3, 20, 30,
37]. It is a standard fact from this literature that if one random variable likelihood-ratio dominates
another, then it also has a strictly greater expected value [20, 37]. We record this fact here in a
general form, since we will need it in some of the subsequent arguments.
(5.2) (See e.g. [20, 37]) Consider two discrete random variables P and Q, each of which takes
values in {u1 , u2P
, . . . , un }, P
with u1 < u2 < · · · < un and n > 1. Let pi = Pr [Pi =Pui ] and qi =
Pr [Qi =P
ui ]; so ni=1 pi = ni=1 qi = 1, and the expected values are given by E [P ] = ni=1 pi ui and
E [Q] = ni=1 qi ui . We will assume that pi > 0 and qi > 0 for all i.
If the sequence of ratios {qi /pi } is strictly monotonically increasing then E [Q] > E [P ].
For completeness, we give a proof (5.2) in the appendix. Using this fact, we can now give a
proof of (5.1).
Proof of (5.1). In the language of random variables, (5.2) is equivalent to showing that for every
set M ⊆ {y1 , . . . , yn } with |M | > 1, we have E [YA | YA ∈ M ] > E [YD | YD ∈ M ].
To prove this, we write M = {yi1 , yi2 , . . . , yic } for i1 < i2 < · · · < ic ⊆ {1, 2, . . . , n}. Let us
hM i
define YD to be the random variable defined on M by
h
i
δi
hM i
Pr YD = yij = Pc j

.

i
h
αi
hM i
Pr YA = yij = Pc j

.

`=1 δi`

hM i

We define YA

analogously by
`=1 αi`

h
i
h
i
hM i
hM i
We observe that E YD
= E [YD | YD ∈ M ] and E YA
= E [YA | YA ∈ M ]. Moreover, we
have
αi
P
Pc j
h
i
h
i
αij c`=1 δi`
hM i
hM i
`=1 αi`
P
=
Pr YA = yij /Pr YD = yij =
,
δi
δij c`=1 αi`
Pc j
`=1 δi`

where the second term in each of the numerator and denominator is independent of j; thus, this
sequence of ratios is strictly monotonically increasing in j because αij /δij is. It follows that the
hM i

likelihood ratio dominance condition as stated in (5.2) holds
variables YA
h for ithe pair
h of random
i
hM i
hM i
hM i
and YD . Hence by (5.2), we have E [YA | YA ∈ M ] = E YA
> E YD
= E [YD | YD ∈ M ] .

23

5.2

A Combinatorial Lemma about Separable Approximators

Recall that an f -approximator g is called separable if each non-trivial cell consists entirely of rows
associated with group A or entirely of rows associated with group D. As a key step in the proof
of (3.12), we will need the following fact: in any non-trivial, separable f -approximator g, there
exists an A-applicant who receives a value that is strictly higher than a D-applicant with the same
feature vector. Given the disadvantage condition, it is intuitively plausible that this should be true.
But given that a number of quite similar-sounding statements are in fact false — essentially, these
statements are very close to what arises in Simpson’s Paradox [6] — some amount of care is needed
in the proof of this fact. (We explore the connection to Simpson’s Paradox in Section 7.)
(5.3) Let g be a non-trivial, separable f -approximator. Then there exists an xj such that g assigns
the row (xj , A) a strictly higher value than it assigns the row (xj , D). That is, (xj , A) and (xj , D)
belong to cells Ca and Cb respectively, and θ(Ca ) > θ(Cb ), where as before θ(C) denotes the average
f -value of the members of a cell C.
Proof. Let the cells containing rows of group D be S1 , S2 , . . . , Sc , and the cells containing rows of
group A be T1 , T2 , . . . , Tm . We define S(j) to be the cell Si for which (xj , D) ∈ Si , and we define T (j)
to be the cell T` for which (xj , A) ∈ T` . For a set of rows M , we also define y(M ) = {f (x) : x ∈ M }.
We take care of two initial considerations at the outset. First, g may contain trivial cells of the
form {(xj , A), (xj , D)}, since separability only requires that each non-trivial cell consist entirely of
rows from the same group. We can modify g so that any such trivial cell is replaced instead by the
two cells {(xj , A)} and {(xj , D)}. If we obtain the result for this modified approximator, it will
hold for the original approximator g as well. Thus, we will henceforth assume that each cell of g
(trivial or non-trivial) consists entirely of rows from the same group.
Second, the result is immediate in the case when all the cells T` associated with group A are
singletons. Indeed, in this case, since g is non-trivial, there must be a cell Si associated with group D
that contains more than one row. We choose such a cell Si , let (xj , D) be the row in Si of maximum
f -value, and let T` be the (singleton) cell consisting of {(xj , A)}. Then θ(Si ) < f (xj ) = θ(T` ), and
the result follows. Thus, we will also henceforth assume that at least one cell of g contains multiple
rows of A.
With these two preliminaries out of the way, we proceed with the main portion of the proof.
We again use the random-variable interpretation, in which YA is the f -value of a candidate drawn
at random from group A, and YD is the f -value of a candidate drawn at random from group D.
Thus we have θ(Si ) = E [YD | YD ∈ y(Si )] and θ(T` ) = E [YA | YA ∈ y(T` )].
The statement we are trying to prove requires that we find a choice of j for which the cell
containing (xj , D) has a strictly lower θ-value than the row containing (xj , A) — that is, a j such
that θ(S(j)) < θ(T (j)). Using the connection to random variables as just noted, this means we
need to find a j for which E [YD | YD ∈ y(S(j))] < E [YA | YA ∈ y(T (j))].
A useful start is to write

24

E [YD ] =

c
X

E [YD | YD ∈ y(Si )] Pr [YD ∈ y(Si )]

i=1

=

c
X





E [YD | YD ∈ y(Si )]

i=1

=

X

δj 

(xj ,D)∈Si

n
X

δj E [YD | YD ∈ y(S(j))]

(1)

j=1

and analogously, for YA , we have

E [YA ] =

m
X

E [YA | YA ∈ y(T` )] Pr [YA ∈ y(T` )]

`=1

=

m
X





E [YA | YA ∈ y(T` )]

`=1

=

n
X

X

αj 

(xj ,A)∈T`

αj E [YA | YA ∈ y(T (j))]

(2)

j=1

Given that E [YD ] < E [YA ], this immediately tells us that there is a j for which
δj E [YD | YD ∈ y(S(j))] < αj E [YA | YA ∈ y(T (j))] .
But this doesn’t actually get us very far, because the terms we care about (E [YD | YD ∈ y(S(j))]
and E [YA | YA ∈ y(T (j))]) are being multipled by different coefficients on the two sides of the
inequality (δj and αj respectively). This is a non-trivial point, since in fact the statement we are
trying to prove would not in fact hold if the only thing we knew about the random variables YD and
YA were the inequality E [YD ] < E [YA ]. (We explore this point further in Section 7.) Thus, we must
use additional structure in the values of δj and αj ; in particular, we will apply the disadvantage
condition (3.1) and its consequence (5.1).
The idea will be to interpose a new quantity that we can compare with both E [YD | YD ∈ y(S(j))]
and E [YA | YA ∈ y(T (j))] for any given index j, and which in this way will allow us to compare
these two quantities to each other by transitivity. To do this, we first observe that Equation (1)
applies to any partition of the rows of group D. We therefore invoke this equation for a second
partition of the rows of group D — in particular, we will partition the rows of D in a way that
“lines up” with the partition T1 , T2 , . . . , Tm used for the rows of group A. With this in mind, we
define the following partition of the rows associated with D: we write T`0 = {(xj , D) : (xj , A) ∈ T` }.
As above, we define T 0 (j) to be the set T`0 for which (xj , D) ∈ T`0 . Following the same argument as
in Equation (1), we have
E [YD ] =

n
X



δj E YD | YD ∈ y(T 0 (j)) .

j=1

25

Subtracting this from Equation (1) for E [YD ], we get
n
X



δj E [YD | YD ∈ y(S(j))] − E YD | YD ∈ y(T 0 (j)) = 0.

(3)

j=1

It will turn out to matter in the remainder of the proof whether or not the index j we are working
with has the property that T 0 (j) is a singleton set (i.e. with |T 0 (j)| = 1). Therefore, viewing the
left-hand side of Equation (3) as a sum over n terms, we group these terms into two sets: let K be
the sum over all terms j for which T 0 (j) is a singleton, and let L be the sum over all terms j for which
|T 0 (j)| > 1. Recall that since we addressed the case in which all sets T` (and hence all sets T`0 ) are
singletons, we can assume that at least one of the sets T`0 has size greater than 1. Thus, the quantity
L is a sum over a non-empty set of terms. In the event that there are no singleton sets T`0 (in which
case there are no terms contributing to the value of K), we declare K = 0. Now, the left-hand side
of Equation (3) by definition is K + L, and so K + L = 0. Thus, we cannot have both K ≥ 0 and
L > 0, and so one of K < 0 or L ≤ 0 must hold. If K < 0, then there must be a j ∗ for which T (j ∗ ) is
a singleton and E [YD | YD ∈ y(S(j ∗ ))] < E [YD | YD ∈ y(T 0 (j ∗ ))]. Alternately, if L ≤ 0, then there
is a j ∗ for which T (j ∗ ) is not a singleton, and E [YD | YD ∈ y(S(j ∗ ))] ≤ E [YD | YD ∈ y(T 0 (j ∗ ))].
In summary, we have thus found an index j ∗ for which


E [YD | YD ∈ y(S(j ∗ ))] ≤ E YD | YD ∈ y(T 0 (j ∗ )) .
(4)
and with the additional property that the inequality is strict in the case that T 0 (j ∗ ) is a singleton.
We now claim that for this j ∗ , we have
E [YD | YD ∈ y(S(j ∗ ))] < E [YA | YA ∈ y(T (j ∗ ))] .

(5)

As discussed at the outset of the proof, this will establish the result, since it says that (xj ∗ , D) and
(xj ∗ , A) belong to cells S(j ∗ ) and T (j ∗ ) respectively, and
θ(S(j ∗ )) = E [YD | YD ∈ y(S(j ∗ ))] < E [YA | YA ∈ y(T (j ∗ ))] = θ(T (j ∗ )).
We establish this claim by considering two cases.
Case 1: |T 0 (j ∗ )| > 1. In this case we can apply (5.1) to conclude that E [YD | YD ∈ y(T 0 (j ∗ ))] <
E [YA | YA ∈ y(T (j ∗ ))]. Combining this with Inequality (4), we obtain Inequality (5) by transitivity.
Case 2: |T 0 (j ∗ )| = 1. Above, we noted that our choice of j ∗ ensures that Inequality (4) is strict
when T 0 (j ∗ ) is a singleton, and so we have


E [YD | YD ∈ y(S(j ∗ ))] < E YD | YD ∈ y(T 0 (j ∗ ))
in this case. Since T 0 (j ∗ ) is a singleton, consisting only of the row (xj ∗ , D), we also have


E YD | YD ∈ y(T 0 (j ∗ )) = E [YA | YA ∈ y(T (j ∗ ))] ,
since both the left- and right-hand sides are equal to f (xj ∗ ). Combining this with the previous
inequality, we obtain Inequality (5) in this case as well.

26

5.3

Proof

We now have all the ingredients needed for proving the first main result.
Proof of (3.12). Let g be a graded f -approximator with cells C1 , . . . , Cd ; thus g is discrete f approximator g with (by non-triviality) at least one cell containing rows x, x0 such that f (x) 6= f (x0 ),
hAi
hDi
hDi
hAi
and such that for every cell Ci , we have Ci ⊆ Ci
or Ci ⊆ Ci . We will create a new f approximator g 0 that strictly improves on g.
hgi
For an index `, recall that r` is the measure of the first ` entries in the list of cells
R r of g. It is
also useful to introduce a further piece of notation for the proof: we write Vg∗ (r) = 0 vRg (t) dt for
r
the unnormalized version of Vg (r) in which we do not divide by r, and we write Wg∗ (r) = 0 wg (t) dt
analogously. In order to show that an approximator g 0 improves on g, we can compare the pairs of
functions Vg∗ , Vg∗0 and Wg∗ , Wg∗0 rather than Vg , Vg0 and Wg , Wg0 in the underlying definition. That is,
it would be equivalent to our earlier definitions of improvement to say that g 0 weakly improves on
g if Vg∗0 (r) ≥ Vg∗ (r) and Wg∗0 (r) ≥ Wg∗ (r) for all r ∈ (0, 1]; and g 0 strictly improves on g if g 0 weakly
improves on g, and there exists r∗ ∈ (0, 1] for which Vg∗0 (r∗ ) > Vg∗ (r∗ ) and Wg∗0 (r∗ ) > Wg∗ (r∗ ).
Inside the proof, it will also be useful to work with objects that are slightly more general than
f -approximators (although the statement of the result itself applies only to f -approximators as we
have defined them thus far). In particular, we will say that h is an f -pseudo-approximator if it
can be obtained from an f -approximator g by possibly rearranging the order of the cells so that
they are no longer in decreasing order of θ-values. We can still consider admissions rules based on
pseudo-approximators h just as we have for approximators g: applicants are admitted according to
the sequence of cells in h, even though they no longer have decreasing θ-values. We can also still
define vh , Vh∗ , wh , and Wh∗ for pseudo-approximators just as we do for approximators, and use them
in the definitions of weak and strict improvement.
We organize the proof into a set of cases. Each case follows the structure outlined in the
discussion after the statement of (3.9): we find a row — or a small portion of a row — that we
can break loose from its current cell and convert into a cell on its own; we then place it at the
position determined by its value in the overall ordering of cells so as to strictly improve the effiency
and the equity of the approximator. Depending on the structure of the initial approximator g, we
will go about selecting the row to use for this improvement in different ways. This distinction is
what determines the decomposition of the proof into cases, but the cases otherwise follow a parallel
structure.
hAi

hDi

Case 1: There is a non-trivial cell Ci such that both Ci
and Ci
are non-empty, and
hAi
hDi
Ci ⊆ Ci . Of all the rows x ∈ Ci , we choose one of maximum f (x). For such an x, we have
f (x) > θ(Ci ), since θ(Ci ) is an average of f -values from multiple rows. Also, at least one row
of maximum f -value must be associated with group D, since for all (xj , A) ∈ Ci we also have
(xj , D) ∈ Ci ; we choose x so that it is associated with group D.
From this row x = (xj , D), we create a new (non-discrete) f -approximator g 0 as follows. For a
small value ε > 0, we create a new cell C 0 that contains an ε measure of row x and nothing else. We
correspondingly subtract an ε measure of row x from cell Ci , creating a new cell Ci0 . This defines
the new approximator g 0 .
These new cells have the property that θ(C 0 ) > θ(Ci ) > θ(Ci0 ), since θ(Ci ) is a weighted average
of f -values among which θ(C 0 ) = f (x) is the largest. The new cell C 0 thus moves ahead of Ci in
the sorted order, to position s < i. By the genericity condition (3.2), we know that θ(Ci ) is distinct

27

from the θ-value of all other cells, and so by choosing ε sufficiently small, Ci0 will retain its position
in the sorted order of the other cells.
The new approximator has cells
C1 , . . . , Cs−1 , C 0 , Cs , . . . , Ci−1 , Ci0 , Ci+1 , . . . , Cd
hgi

hgi

in sorted order. Observe that rs−1 is the measure of the cells in the list preceding C 0 , and ri is
the measure of the cells through Ci0 . (For this latter point, note that there are i + 1 entries in the
list of cells of g 0 through Ci0 , but since two of these cells are a partition of Ci , the total measure of
hgi
these i + 1 cells is ri .)
For comparing the functions Vg∗ and Vg∗0 , it is useful to interpose the following pseudo-approximator
h. The pseudo-approximator h is obtained by writing the cells of g 0 in the order
C1 , . . . , Cs−1 , Cs , . . . , Ci−1 , C 0 , Ci0 , Ci+1 , . . . , Cd
rather than in their sorted order. As noted above, we can still define vh , Vh∗ , wh , and Wh∗ as before,
and use them in the definition of weak and strict improvement.
hgi hgi
We observe first that Vg∗ and Vh∗ agree outside the interval [ri−i , ri ], and inside this interval
we have Vh∗ (r) > Vg∗ (r), since θ(C 0 ) > θ(Ci0 ). Similarly, Wg∗ and wh agree outside the interval
hgi

hgi

[ri−i , ri ], and inside this interval we have Wh∗ (r) > Wg∗ (r), since σ(C 0 ) = 1 and σ(Ci0 ) < 1. Thus,
h  g.
Now, we obtain g 0 from h by moving the cell C 0 forward to position s in the sorted order. The
hgi
hgi
hgi
hgi
functions Vg∗0 and Vh∗ are thus the same for r ≤ rs−1 and r ≥ ri . In the interval (rs−1 , ri ),
they differ in that we have moved the cell C 0 forward to the beginning of this interval. For all
hgi
hgi
r ∈ (rs−1 , ri ), we have θ(C 0 ) ≥ θ(Cj(r) ) because C 0 comes earlier in the sorted order, and 1 =
hgi

hgi

σ(C 0 ) ≥ σ(Cj(r) ). Thus, Vg∗0 (r) ≥ Vh∗ (r) and Wg∗0 (r) ≥ Wh∗ (r) for all r ∈ (rs−1 , ri ) and so we have
g 0  h.
By our result (3.6) on transitivity, it follows that g 0  g.
hAi

hDi

hDi

hAi

Case 2: There is a cell Ci such that both Ci and Ci
are non-empty, and Ci
⊆ Ci .
We proceed by close analogy with Case 1, except that instead of removing a small measure of
a row (xj , D) of high f -value from Ci , we remove a small measure of a row (xj , A) of low f value. Specifically, of all the rows x ∈ Ci , we choose one of minimum f (x). For this x, we have
f (x) < θ(Ci ), and we can choose x to have the form (xj , A), since for all (xj , D) ∈ Ci we also have
(xj , A) ∈ Ci .
For a small value ε > 0, we create a new cell C 0 that contains an ε measure of row x and nothing
else. We correspondingly subtract an ε measure of row x from cell Ci , creating a new cell Ci0 . This
defines the new approximator g 0 . The new cell C 0 moves after Ci in the sorted order, to position
t > i, and by choosing ε sufficiently small, Ci0 retains its position; so the new approximator g 0 has
cells
C1 , . . . , Ci−1 , Ci0 , Ci+1 , . . . , Ct−1 , C 0 , Ct , . . . , Cd .
As in Case 1, we interpose a pseudo-approximator h with the same cells as g 0 , but in an order
that is not necessarily sorted:
C1 , . . . , Ci−1 , Ci0 , C 0 , Ci+1 , . . . , Ct−1 , Ct , . . . , Cd .
28

hgi

hgi

Now, Vg∗ and Vh∗ agree outside the interval [ri−i , ri ], and inside this interval we have Vh∗ (r) >
hgi

hgi

Vg∗ (r), since θ(Ci0 ) > θ(C 0 ). Similarly, Wg∗ and Wh∗ agree outside the interval [ri−i , ri ], and inside
this interval we have Wh∗ (r) > Wg∗ (r), since σ(Ci0 ) > 0 and σ(C 0 ) = 0. Thus, h  g.
Now, we obtain g 0 from h by moving the cell C 0 back to position t in the sorted order. The
hgi
hgi
hgi
hgi
functions Vg∗0 and Vh∗ are thus the same for r ≤ ri−1 and r ≥ rt−1 . In the interval (ri−1 , rt−1 ), they
hgi

hgi

differ in that we have moved the cell C 0 back to the end of this interval. For all r ∈ (ri−1 , rt−1 ), we
have θ(C 0 ) ≤ θ(Cj(r) ) because C 0 comes later in the sorted order, and 0 = σ(C 0 ) < σ(Ci0 ). Thus,
hgi

hgi

Vg∗0 (r) ≥ Vh∗ (r) and Wg∗0 (r) ≥ Wh∗ (r) for all r ∈ (ri−1 , rt−1 ) and so we have g 0  h. By transitivity,
it follows that g 0  g.
If neither of Cases 1 or 2 holds, then every non-trivial cell of g consists entirely of rows associated
with A or entirely of rows associated with D. Thus our final case is the following.
Case 3: g is separable. In this case, (5.3) implies that there is an xj such that (xj , A) and
(xj , D) belong to cells Ca and Cb respectively, and θ(Ca ) > θ(Cb ). This case follows a similar
high-level strategy to Cases 1 and 2, but using the existence of xj and the cells Ca and Cb to create
a new cell. The construction of this new cell involves moving a small amount of measure out of Ca
or Cb , and in some cases out of both cells. For this case, we consider a set of sub-cases, depending
on the relative ordering of f (xj ) with respect to θ(Ca ) and θ(Cb ).
Case 3a: f (xj ) ≥ θ(Ca ) > θ(Cb ). We define an f -approximator g 0 by creating a new cell C 0
that, for a small ε > 0, contains an ε measure of row (xj , D) and nothing else. We correspondingly
subtract an ε measure of row (xj , D) from cell Cb , creating a new cell Cb0 . We put C 0 in its
appropriate place in the sorted order of cells, and ahead of Ca in the case that f (xj ) = θ(Ca ); so
C 0 goes into some position s ≤ a. The cells of g 0 in order are thus
C1 , . . . , Cs−1 , C 0 , Cs , . . . , Ca , . . . , Cb−1 , Cb0 , Cb+1 , . . . , Cd ,
where possibly Cs = Ca . We also consider the pseudo-approximator h with these same cells in the
order
C1 , . . . , Cs−1 , Cs , . . . , Ca , . . . , Cb−1 , C 0 , Cb0 , Cb+1 , . . . , Cd .
hgi

hgi

The functions Vg∗ and Vh∗ agree outside the interval (rb−1 , rb ), and for r in this interval we have
Vh∗ (r) > Vg∗ (r). When we then move C 0 forward to its correct position in sorted order, producing
hgi

hgi

g 0 , we see that the functions Vg∗ and Vg∗0 agree outside the interval (rs−1 , rb ); and for r in this
interval, we have Vg∗0 (r) > Vg∗ (r).
hgi

hgi

hgi

hgi

Similarly, the functions Wg∗ and Wg∗0 agree for r ≤ rs−1 and r ≥ rb . For rs−1 < r < rb , the
functions Wg∗ and Wg∗0 differ in the fact that cell C 0 with σ(C 0 ) = 1 was moved ahead of Cs , so for
all such r we have Wg∗0 (r) ≥ Wg∗ (r). Now, let C` be the next cell after C 0 for which σ(C` ) < 1;
hg 0 i

hg 0 i

we have ` ≤ a, since σ(Ca ) = 0. For r` < r < r`+1 , the marginal applicant is being drawn from
C` , and hence Wg∗0 (r) > Wg∗ (r) for such r. Since this r is also in the range noted above where
Vg∗0 (r) > Vg∗ (r), we have g 0  g.
Case 3b: θ(Ca ) > θ(Cb ) ≥ f (xj ). We define an f -approximator g 0 by creating a new cell C 0
that, for a small ε > 0, contains an ε measure of row (xj , A) and nothing else. We correspondingly
subtract an ε measure of row (xj , A) from cell Ca , creating a new cell Ca0 . We put C 0 in its

29

appropriate place in the sorted order of cells, and after Cb in the case that f (xj ) = θ(Cb ); so C 0
goes into some position t > b. The cells of g 0 in order are thus
C1 , . . . , Ca−1 , Ca0 , Ca+1 , . . . , Cb , . . . , Ct−1 , C 0 , Ct , . . . , Cd .
We also consider the pseudo-approximator h with these same cells in the order
C1 , . . . , Ca−1 , Ca0 , C 0 , Ca+1 , . . . , Cb , . . . , Ct−1 , Ct , . . . , Cd .
hgi

hgi

The functions Vg∗ and Vh∗ agree outside the interval (ra−1 , ra ), and for r in this interval we have
Vh∗ (r) > Vg∗ (r). When we then move C 0 back to its correct position in sorted order, producing
hgi

hgi

g 0 , we see that the functions Vg∗ and Vg∗0 agree outside the interval (ra−1 , rt−1 ); and for r in this
interval, we have Vg∗0 (r) > Vg∗ (r).
hgi

hgi

hgi

hgi

The functions Wg∗ and Wg∗0 agree for r ≤ ra−1 and r ≥ rt−1 . For ra−1 < r < rt−1 , the functions
and Wg∗0 differ in the fact that cell C 0 with σ(C 0 ) = 0 was moved after Ct−1 , so for all such r
we have Wg∗0 (r) ≥ Wg∗ (r). Now, let C` be the next cell after Ca0 for which σ(C` ) > 0; we have ` ≤ b,

Wg∗

hg 0 i

hg 0 i

since σ(Cb ) = 1. For r` < r < r`+1 , the marginal applicant is being drawn from C` , and hence
Wg∗0 (r) > Wg∗ (r) for such r. Since this r is also in the range noted above where Vg∗0 (r) > Vg∗ (r), we
have g 0  g.
Case 3c: θ(Ca ) > f (xj ) > θ(Cb ). In this case, we define an f -approximator g 0 by creating a
new cell C 0 that, for a small ε > 0, contains an ε measure of row (xj , A) and an ε measure of row
(xj , D). We correspondingly subtract an ε measure of row (xj , A) from cell Ca , creating a new cell
Ca0 , and we subtract an ε measure of row (xj , D) from cell Cb , creating a new cell Cb0 . We put C 0
in its appropriate place in the sorted order of cells, which is in some position i with a < i ≤ b. The
cells of g 0 in order are thus
C1 , . . . , Ca−1 , Ca0 , . . . , C 0 , . . . , Cb0 , Cb+1 , . . . , Cd .
We consider two pseudo-approximators h and h0 . For these, we define Ca+ to be a cell consisting
only of an ε measure of row (xj , A), and we define Cb+ to be a cell consisting only of an ε measure
of row (xj , D). Note that C 0 is obtained by merging Ca+ and Cb+ together. We define h to have the
sequence of cells
C1 , . . . , Ca−1 , Ca0 , Ca+ , . . . , Cb+ , Cb0 , Cb+1 , . . . , Cd .
We define h0 to be obtained from h by shifting Ca+ later if necessary and Cb+ forward if necessary
so they are consecutive in position i.
hgi
hgi
hgi
hgi
Now, the functions Vg∗ and Vh∗ agree outside the intervals (ra−1 , ra ) and (rb−1 , rb ); inside
these intervals we have Vh∗ (r) > Vg∗ (r). When we move Ca+ and Cb+ to be adjacent in position i,
hgi

hgi

we obtain h0 with Vh∗0 (r) > Vg∗ (r) for r ∈ (ra−1 , rb ) (and the same function outside this interval).
Finally, Vh∗0 and Vg∗0 are the same function everywhere.
hgi

hgi

hgi

hgi

The functions Wg∗ and Wh∗0 agree for r ≤ ra−1 and r ≥ rb . For ra−1 < r < rb , the functions
∗
Wg and Wh∗0 differ in the fact that cell Ca+ with σ(Ca+ ) = 0 was moved after Ci−1 , and cell
hgi

hgi

Cb+ with σ(Cb+ ) = 1 was moved forward to be just behind it; so for all r ∈ (ra−1 , rb ) we have
Wh∗0 (r) ≥ Wg∗ (r). Since g 0 is obtained from h0 by simply combining the adjacent cells Ca+ and Cb+
into the single cell C 0 , we have Wg∗0 (r) ≥ Wh∗0 (r) for all r. Now, let C` be the next cell of g 0 after
30

hg 0 i

hg 0 i

Ca0 for which σ(C` ) > 0; C` must be before or equal to C 0 , since σ(C 0 ) = 1/2. For r`−1 < r < r` ,
the marginal applicant is from C` , so Wg∗0 (r) > Wg∗ (r) for such r. Since this r is in the range noted
above where Vg∗0 (r) > Vg∗ (r), we have g 0  g.

5.4

The Role of Non-Discrete Approximators

The proof of (3.12) showed how an arbitrary graded f -approximator g could be improved by
another f -approximator g 0 . The construction in the proof produced f -approximators that were
not necessarily discrete, and it is natural to ask whether the use of non-discrete approximators
was esssential for the result; is it possible that for every graded f -approximator, there is a discrete
f -approximator that strictly improves it?
In fact, there exist graded f -approximators g such that every approximator strictly improving g
is non-discrete; this establishes that non-discrete approximators are indeed necessary for the result.
In this section, we give an example of such a graded approximator.
We use the example from Figure 1 in Section 4, with the parameters y10 and y01 close enough
to 0 so that the following holds: if S is the set of three rows {(1, 1, D), (0, 1, D), (0, 0, D)}, then
f |S > f (1, 0, D). For the function f given in Figure 1, consider the following f -approximator g: it
consists of cells C1 , C2 , . . . , C6 , where C1 is the row (1, 1, A), C2 = S, and C3 , C4 , C5 , C6 are each
singleton sets consisting of the rows (1, 0, D), (1, 0, A), (0, 1, A), and (0, 0, A) respectively.
If we follow the construction used in the proof of (3.12), we arrive at the following non-discrete
f -approximator g 0 that strictly improves g. Let C0 (ε) be the cell consisting of an ε measure of the
row (1, 1, D), and let C20 (ε) be the cell we obtain by starting with C2 and removing an ε measure
of the row (1, 1, D). We also define the cell C200 (ε) to consist of C20 (ε) together with C3 . As we
increase ε, the value of θ(C20 (ε)) decreases monotonically; and by the time ε reaches µ(1, 1, D), we
have θ(C20 (ε)) < θ(C3 ), since for this value of ε, the cell C20 (ε) consists of just the rows (0, 1, D)
and (0, 0, D). We can therefore find an ε∗ > 0 such that θ(C20 (ε)) = θ(C3 ), and we define the
f -approximator g 0 to consist of the cells
C0 (ε∗ ), C1 , C200 (ε∗ ), C4 , C5 , C6 .
g 0 is a non-discrete f -approximator that strictly improves g.
However, it turns out that the only f -approximators that strictly improve g are non-discrete,
as we establish in the following.
(5.4)

There is no discrete f -approximator that strictly improves g.

Proof. Let h be a discrete f -approximator that weakly improves g. We will show that h does not
strictly improve g.
Let s1 = µ(1, 1, A) and s2 = µ(1, 1, A) + 1/2; we recall that the measure of all rows associated
with group D is 1/2. We observe that (i) Vh (s1 ) ≥ Vg (s1 ) = 1, and (ii) Wh (s2 ) ≥ Wg (s2 ) =
1/(1 + 2s1 ). Since µ(1, 1, A) > µ(1, 1, D), fact (i) implies that the row (1, 1, A) must be in a cell
C by itself or with just (1, 1, D). Fact (ii) implies that all rows associated with D must occur in
cells that come before every row associated with A except for (1, 1, A). From this we can conclude
that the row (1, 1, D) must occur in a cell C 0 together with rows (0, 1, D) and (0, 0, D); and hence
C consists of just the row (1, 1, A).
Now, recall that S is the set of rows {(1, 1, D), (0, 1, D), (0, 0, D)}. Since h weakly improves g,
and since f |S > f (1, 0, D), it follows that C 0 = S, and the first two cells of h are C and C 0 . The

31

remaining cells of g are singleton rows, and so there is no value of r for which Vh (r) > Vg (r). Hence
h does not strictly improve g, as required.

6

Proof of Second Result:
Simplicity Can Transform Disadvantage Into Bias

In this section we prove our second main result, (3.10).
Since (3.10) is concerned with the process of taking a group-agnostic f -approximator g and
splitting its non-trivial cells by group to produce χ(g), it is useful to first consider the effect of
splitting a single non-trivial cell in this way. By considering such single steps first, we can then
analyze a sequence of such steps to go from g to χ(g).
Given this plan, it is useful to introduce some terminology and notation for individual cells.
Given a discrete f -approximator g, we say that one of its cells C is group-agnostic if C hAi = C hDi
in the notation of the previous sections; that is, if for all feature vectors x, we have (x, A) ∈ C if
and only if (x, D) ∈ C. We will use χA (C) to denote {(x, A) : (x, A) ∈ C}, and χD (C) to denote
{(x, D) : (x, D) ∈ C}, and we say g 0 is obtained from g by splitting C if g 0 has the same cells as g,
but with C replaced by the two cells χA (C) and χD (C).
Using the disadvantage condition (3.1) and its consequence (5.1), we now prove
(6.1) Let g be a discrete f -approximator, and let C be a non-trivial group-agnostic cell of g. Let
g 0 be the approximator obtained from g by splitting C. Then g 0 strictly improves g in efficiency,
and g strictly improves g 0 in equity.
Proof. Let the cells of g be C1 , . . . , Cd , with C = Ci the non-trivial group-agnostic cell that we split
to obtain g 0 . Since C is non-trivial, it contains at least two rows associated with each of groups A and
D, and hence (5.1) implies that θ(χA (C)) > θ(χD (C)). Moreover, since θ(C) is a weighted average
of θ(χA (C)) and θ(χD (C)), we can extend this inequality to say θ(χA (C)) > θ(C) > θ(χD (C)).
Now, g 0 consists of the cells C1 , . . . , Ci−1 , Ci+1 , . . . , Cd together with χA (C) and χD (C). In the
ordering of these cells by θ-value, suppose that χA (C) comes just after cell Ca , and χD (C) comes
just before cell Cb , where a < b. Thus, the cells of g 0 are
C1 , . . . , Ca , χA (C), . . . , χD (C), Cb , . . . , Cd .
We also recall the notion of pseudo-approximators from the proof of (3.12) in the previous section;
these are simply the analogues of approximators in which the cells do not need to be arranged in
descending order of θ-values. In particular, it will be useful to consider the pseudo-approximator h
in which χA (C) and χD (C) are adjacent between Ci−1 and Ci+1 ; that is, h has cells
C1 , . . . , Ca , . . . , Ci−1 , χA (C), χD (C), Ci+1 , . . . , Cb , . . . , Cd ,
where either or both of a = i − 1 or i + 1 = b might hold.
hgi
hgi
Now, the functions Vg∗ (r) and Vh∗ (r) agree for r outside the interval [ri−1 , ri ], and inside this
interval we have Vh∗ (r) > Vg∗ (r), since θ(χA (C)) > θ(χD (C)). Similarly, the functions Wg∗ (r) and
hgi

hgi

Wh∗ (r) agree for r outside the interval [ri−1 , ri ], and inside this interval we have Wh∗ (r) < Wg∗ (r),
since σ(χA (C)) = 0 and σ(χD (C)) = 1. Thus h strictly improves g in efficiency, and g strictly
improves h in equity. Using our notation from earlier, we can write this as h v g and g w h.
Next, we obtain g 0 from h by moving the cell χA (C) forward so that it follows Ca , and moving
the cell χD (C) backward to that it comes before Cb . (In each case, the cell might not actually
32

change position if a = i − 1 or i + 1 = b respectively.) Thus, Vg∗0 and Vh∗ agree outside the interval
hgi

hgi

[ra , rb−1 ], and inside this interval we have Vg∗0 (r) ≥ Vh∗ (r). Similarly, Wg∗0 and Wh∗ agree outside
hgi

hgi

the interval [ra , rb−1 ], and since σ(χA (C)) = 0 and σ(χD (C)) = 1, we have Wg∗0 (r) ≤ Vh∗ (r) inside
this interval.
It follows that Vg∗0 (r) ≥ Vh∗ (r) and Wg∗0 (r) ≤ Vh∗ (r) for all r ∈ (0, 1]. Since we established above
that h v g and g w h, it follows by transitivity that g 0 v g and g w g 0 .
We will now apply (6.1) iteratively in a construction that converts g into χ(g) one split at a
time to prove (3.10).
Proof of (3.10). Let g be a non-trivial, group-agnostic f -approximator, with cells C1 , C2 , . . . , Cd
sorted so that the values θ(Ci ) are in descending order. Since g is non-trivial, it contains at least
one non-trivial cell.
We are going to imagine modifying g into χ(g) by splitting one non-trivial cell at a time,
comparing the efficiency and equity after each individual cell is split via (6.1), and then using
transitivity to compare the efficiency at the beginning and end of the process. As before, for a
non-trivial cell Ci , we let χA (Ci ) = {(x, A) : (x, A) ∈ Ci }, and χD (Ci ) = {(x, D) : (x, D) ∈ Ci }.
Let gj0 be the f -approximator obtained by applying the splitting operation to all non-trivial cells
Ci with i ≤ j; that is, we construct gj0 by replacing each non-trivial cell Ci , for i ≤ j, with the two
cells χA (Ci ) and χD (Ci ). (For notational consistency, we will sometimes use g00 to denote g.)
Note that we do not need to consider the effect of splitting any of the trivial cells of g: the
definition of χ(g) involves merging together cells of the same θ-value, and this would be true of
two singleton cells of the form {(x, A)} and {(x, D)}; they would be merged together into a single
cell. Thus, if the two-element set {(x, A), (x, D)} is a cell of g, then it will also be a cell of χ(g). It
follows that after we have split all the non-trivial cells, we have produced χ(g); that is, gd0 = χ(g).
0
Now, if Cj is a non-trivial cell, then gj0 is obtained from gj−1
by splitting the single non-trivial
0
0
0
cell Cj . If follows from (6.1) that gj strictly improves gj−1 in efficiency, and gj−1
strictly improves
0
gj in equity. Since g has at least one non-trivial cell, it then follows by transitivity that gd0 = χ(g)
strictly improves g00 = g in efficiency, and g00 = g strictly improves gd0 = χ(g) in equity, as required.

7

The Role of the Disadvantage Condition

A further natural question to ask is how much we can weaken the disadvantage condition (3.1)
and still derive the conclusions of our main results. That is, how extensive does the disadvantage
of group D relative to group A have to be in order for every graded approximator to be strictly
improvable; and in order for every non-trivial group-agnostic approximator to create an incentive
for using group membership in a way that’s biased against group D?
While we do not know the exact answer to this question, we can show that it is not sufficient
to require only a difference in means — i.e., to require only that the average f -value of the Aapplicants exceeds the average f -value of the D-applicants. Thus, the “boundary” between those
disadvantage conditions that yield the main results and those that do not lies somewhere between
condition (3.1) and a simple difference in means.
To write this using more compact notation, let UA be the set of all rows associated with group
A, and UD be the set of all rows associated with group D. We will show that there are instances
33

xh1i
1
1
1
1
0
0
0
0

xh2i
1
1
0
0
1
1
0
0

γ
D
A
D
A
D
A
D
A

f
.9
.9
.6
.6
.2
.2
.02
.02

µ
.06
.04
.02
.06
.07
.06
.35
.34

Figure 5: An example of a function f in which the average f -value of the A-applicants exceeds the
average f -value of the D-applicants; but the simple f -approximator that projects out the variable
xh2i is not strictly improvable.

for which f |UA > f |UD , but for which (i) there exist graded approximators that are not strictly
improvable, and (ii) there are non-trivial group-agnostic approximators for which the addition of
the group membership variable benefits group D rather than group A. We will see, however, that
the instances with this property also reveal some of the subtleties inherent in defining what we
mean intuitively by disadvantage.
An Example with a Difference in Means. The example we consider, shown in Figure 5,
is derived from the following high-level considerations. We construct a function f that depends
on the two variables xh1i and xh2i (which appear, as usual, together with a group membership
variable γ that doesn’t affect the value of f ). We define f so that its value increases when either
of xh1i or xh2i is changed from 0 to 1; but the variable xh1i has, informally, a more significant effect
on the value of f than the variable xh2i does. Group A has more applicants with xh1i = 1 than
group D does; however, for each fixed value of xh1i , group D has a larger fraction of applicants
with xh2i = 1. Because we can arrange the construction so that it has these properties, the fact
that xh1i has a larger effect on f means that group A will have a higher average f -value; but a
simple f -approximator that ignores the value of xh2i will be favorable for group D, since it will be
averaging over possible values of xh2i given the value of xh1i .
Figure 5 shows the details of how we carry this out.3 With numbers as in the figure, simple
calculations show that the average f -value of the A-applicants is f |UA = .1816, while the average
f -value of the D-applicants is f |UD = .174. However, consider the four cells obtained by ignoring
the value of xh2i for each applicant. That is, for a ∈ {0, 1} and b ∈ {A, D}, we define the cell
Ca,b to consist of all rows in which the value of xh1i is a and the value of the group membership
variable γ is b. Again, simple calculations show that θ(C1,D ) = .825; θ(C1,A ) = .72; θ(C0,D ) = .05;
θ(C0,A ) = .047; and this is the ordering of the cells by θ-value.
Now, consider the f -approximator g that uses these four cells. From the calculations above, we
can easily verify the following two claims.
3

The example used in the figure does not satisfy the genericity condition as written — for example, there are two
distinct subsets of rows with average value equal to .22 — but by perturbing all values very slightly we can obtain
the same relative ordering of all values and hence the same conclusions while ensuring the genericity condition. For
ease of exposition, we explain the example using the simpler numbers depicted in the figure.

34

(i) g is simple, and it is not strictly improvable, since the only ways of strictly increasing its
equity at any value of r would have the effect of reducing its efficiency.
(ii) If we let h be the f -approximator that uses just the two cells C1,D ∪C1,A and C0,D ∪C0,A , then h
is non-trivial and group-agnostic, and g = χ(h). But g strictly improves h in both efficiency
and equity, which by (3.10) cannot happen in the presence of our stronger disadvantage
condition (3.1).
Intuitively, what’s happened in this example is that in the absence of any information about an
applicant, our estimate of the f -value of a random A-applicant exceeds our estimate for a random
D-applicant. However, if we condition on either xh1i = 0 or on xh1i = 1, we expect the random
D-applicant to have a higher f -value, since they are more likely to have xh2i = 1. That is, whatever
we learn about the value of xh1i , it causes us to start favoring the random D-applicant over the
random A-applicant. The result is that each cell of g consisting of rows of D comes ahead of the
corresponding cell consisting of rows of A; this is why g is not strictly improvable, and why g
strictly improves h in both efficiency and equity.
The surprising property that makes this example work is an instance of Simpson’s Paradox [6],
noted earlier, which roughly speaking describes situations in which the unconditional mean over one
population A exceeds the unconditional mean over another population D; but there is a variable x
such that when we condition on any possible value of x, the conditional mean over D exceeds the
conditional mean over A. It is informative to contrast this with the situation when we impose the
stronger condition (3.1). In this case, we can think of our combinatorial lemma (5.3) as showing
that the structure of Simpson’s Paradox cannot happen in the presence of (3.1).
The example in Figure 5 also raises the question of when we should view a weakening of
(3.1) as corresponding intuitively to disadvantage. Specifically, although the average f -value of
D-applicants in our example is lower than the average f -value of A-applicants — and this is clearly
a kind of disadvantage — the example also has the property that the highest values of f , when
(xh1i , xh2i ) = (1, 1), are in fact characterized by an overrepresentation of group D. (And more
generally, group D is favored once we fix either choice of value for xh1i .) Condition (3.1), on the
other hand, ensures that the decreasing representation of group D continues at all levels as we
increase the value of f . As suggested at the outset, finding the weakest version of the disadvantage
condition for which our result holds is an interesting open question.

8

Further Direction: Approximators with a Bounded Number of
Variables

Our result (3.10) on group-agnostic approximators showed that in the presence of disadvantage,
an approximator’s efficiency can be strictly improved if we incorporate information about group
membership. Essentially, this captures a scenario in which a decision-maker has the option of
keeping all the information they currently have available, and adding group membership on top.
As an interesting direction for possible further exploration, in this section we consider a related
but distinct question: if we have a limited budget of variables that we can measure in our construction of an approximator, is it ever worthwhile — from an efficiency-maximizing perspective — to
use group membership γ instead of a more informative variable xhii ? If we have a function f that
depends on xhii but not on γ, such a situation would have the following striking implication: that
in optimally simplifying a function f by consulting only a reduced set of variables, we may end up
35

with an incentive to use group membership — which is irrelevant to the actual value of f — in
place of another variable that actually affects the f -value.
As we will show next, it is possible to construct examples of such functions. While such a
construction is related to the general result (3.10) proved in Section 6, it addresses a distinct issue
— the preference for using group membership instead of other variables, rather than the efficiency
benefits of adding group membership to an existing set of variables.
Our construction in this section is essentially providing an existence result, showing that such
a phenomenon is possible. It appears to be an interesting open question to characterize more
extensively when this preference for group membership in the presence of a budget constraint can
arise, or to provide a robust set of sufficient conditions for it to arise.
A construction. For our construction, we will work with a natural 4-variable generalization of
the function from Figure 1 in Section 4, which we describe again here from first principles for the
sake of completeness. For ease of exposition, we work out the example with a structured version
of the function that does not satisfy the genericity condition (3.2). However, by subsequently
perturbing the function values and probabilities by arbitrarily small amounts, we can obtain an
example that satisfies the genericity condition, and for which the same conclusions hold.
We start with Boolean variables xh1i , xh2i , xh3i and a group membership variable γ, and we
define f to be the majority function on xh1i , xh2i , xh3i , which takes the value 1 when a majority of
the coordinates xh1i , xh2i , xh3i are equal to 1. That is, for a feature vector x = (xh1i , xh2i , xh3i ), we
define f to take the value 1 when 2 or 3 of the coordinates xhii are equal to 1, and to take the value
0 when 0 or 1 of the coordinates xhii are equal to 1.
We assume (as in Section 4) that half the applicants belong to A and half to D, and the values of
the variables xh1i , xh2i , xh3i are set at random for each individual in a way that reflects disadvantage:
for a small ε > 0, and probability values p1 , p2 , p3 each equal to 1 − ε, an A-applicant has each
xi set equal to 1 independently with probability pi , and a D-applicant has each xi set equal to 1
independently with probability qi = 1 − pi .
As noted above, by perturbing the values of f very slightly, and perturbing the values of p1 , p2 ,
and p3 very slightly as well, we can obtain an example satisfying the genericity and disadvantage
conditions, and for which the subsequent arguments will also hold. However, since the exposition
is much cleaner with the structured instance in which f is precisely the majority function, and all
pi are equal to 1 − ε, we work out the consequences of the example in this structured form.
Bounding the Number of Variables Used. Now suppose we only cared about optimizing
efficiency, not equity, and for some constant c, we wanted to use an approximator that only consulted
the values of c of the variables. Which approximator would be the best one to use?
If c = 3 (so that we are required to ignore one of the variables xh1i , xh2i , xh3i , γ), the answer
is clear: since f is not affected by the value of γ once the values of the other three variables are
known, we can ignore γ and still have a perfect approximation to f .
But what about at the other extreme, when c = 1? Here we are choosing among four possible
approximators: gi (for i = 1, 2, 3) which only consults the value of xi ; and g0 , which only consults
the value of γ. Since in this section we are only concerned about efficiency, not equity, we will only
ask — for pairs of approximators g and h — whether one strictly improves the other in efficiency.
In the remainder of this section, we prove

36

(8.1) For the given function f , and a sufficiently small positive value of the parameter ε, the
approximator g0 strictly improves each of g1 , g2 , g3 in efficiency.
Before proceeding to the proof, let us note that (8.1) captures the striking effect we were
seeking from the construction. Specifically, we have a function that depends on only three of its
four variables (x1 , x2 , x3 but not γ). Yet if we are told that we can only find out the value of one of
these four variables for a given individual, the optimal choice is to select the “irrelevant” variable γ
rather than any of the others. This is because γ contains so much information about disadvantage
— in the form of distributional information about the other variables — that it is more valuable for
estimating f than any one of the variables that actually affect the value of f . Thus, our construction
here, like the general result of Section 6, shows how simplifying approximations to f can have the
effect of transforming the underlying disadvantage into bias.
Proof of (8.1).
For each of i = 1, 2, 3, the approximator gi creates two cells: Ci1 , containing
all applicants for whom xhii = 1, and Ci2 , containing all applicants for whom xhii = 0. We have
µ(Ci1 ) = pi /2 + qi /2 = 1/2, and so µ(Ci2 ) = 1/2 as well. The approximator g0 also creates two
cells: C01 , containing all applicants for whom γ = A, and C02 , containing all applicants for whom
γ = D. Here too we have µ(C01 ) = µ(C02 ) = 1/2.
Thus, for all four approximators gi (i = 0, 1, 2, 3), if we think of the average f -value of admitted
applicant Vgi (r) as a function of r, this function maintains a constant value for all r ≤ 1/2 as
applicants from the higher cell are admitted, and then it decreases linearly to a shared value —
the average f -value over the whole population — at r = 1 as applicants from the lower cell are
admitted. It follows that in order to show that g0 strictly improves each of g1 , g2 , g3 in efficiency,
we only need to show that when we seek to admit precisely r = 1/2 of the applicants, the average
f -value admitted under g0 is strictly higher than under g1 , g2 , or g3 ; that is, Vg0 (1/2) > Vgi (1/2)
for i = 1, 2, 3.
We thus turn to a comparison of Vg0 (1/2) and Vgi (1/2) for i = 1, 2, 3. For i = 1, 2, 3, the value
Vgi (1/2) is the total f -value of all applicants with xhii = 1, divided by the normalizing constant
1/2. This is a sum of eight terms: in the 16 rows of the look-up table that defines f , eight of these
rows have xhii = 1, and these are the rows that contribute to the value Vgi (1/2). That is, we have
X
Vgi (1/2) = 2
µ(x, γ)f (x, γ).
(x,γ):xhii =1

Since the sum has the same value for each of g1 , g2 , and g3 , we evaluate it for g1 , using the following
enumeration:
• Its largest term is µ(1, 1, 1, A)f (1, 1, 1, A) = (1 − ε)3 .
• The next largest terms are µ(1, 1, 0, A)f (1, 1, 0, A) and µ(1, 0, 1, A)f (1, 0, 1, A), which are both
equal to ε(1 − ε)2 .
• The next largest terms after that are µ(1, 1, 0, D)f (1, 1, 0, D) and µ(1, 0, 1, D)f (1, 0, 1, D),
which are both equal to ε2 (1 − ε).
• The term µ(1, 1, 1, D)f (1, 1, 1, D) is equal to ε3 .
• The remaining two terms µ(1, 0, 0, A)f (1, 0, 0, A) and µ(1, 0, 0, D)f (1, 0, 0, D) are both equal
to 0.
37

Thus (recalling that there is also a factor of 2 in front of the overall sum), we have
Vgi (1/2) = 2(1 − ε)3 + 4ε(1 − ε)2 + 4ε2 (1 − ε) + 2ε3 .
Now, for comparison, we evaluate Vg0 (1/2), which is the total f -value of all applicants with
γ = A, divided by the normalizing constant 1/2. This too is a sum of eight terms, as follows:
X
µ(x, γ)f (x, γ).
Vg0 (1/2) = 2
(x,γ):γ=A

We can evaluate this sum as follows.
• Its largest term is µ(1, 1, 1, A)f (1, 1, 1, A) = (1 − ε)3 , as in the previous case of Vgi (1/2).
• It also contains the three terms µ(1, 1, 0, A)f (1, 1, 0, A), µ(1, 0, 1, A)f (1, 0, 1, A), and µ(0, 1, 1, A)f (0, 1, 1, A),
each of which is equal to ε(1 − ε)2 .
• The other four terms all have feature vectors x in which a majority of the coordinates xhii
are equal to 0; therefore, f evaluates to 0 on these feature vectors, and so each of these terms
is 0.
Thus
Vg0 (1/2) = 2(1 − ε)3 + 6ε(1 − ε)2 .
Comparing values by subtracting them, we have
Vg0 (1/2) − Vgi (1/2) = 2ε(1 − ε)2 − 4ε2 (1 − ε) − 2ε3 .
For sufficiently small ε > 0, the first of these three terms is arbitrarily larger than the other two,
and hence the difference is positive. It follows that Vg0 (1/2) > Vgi (1/2). As argued above, this is
sufficient to show that g0 strictly improves gi in efficiency, completing the proof of (8.1).

9

Further Related Work

As discussed in Section 1, our work is connected to the growing literatures on algorithmic fairness
[4, 9, 12, 14] and on interpretability [11, 28, 38]. Within the literature on fairness, there has been
a line of recent research showing conflicts between different formal definitions of what it means
for a prediction function to be fair [5, 7, 10, 26]; a key distinction between that work and ours is
that the tensions we are identifying arise from a syntactic constraint on the form of the prediction
function — that it follow our definition of simplicity — rather than a fairness requirement on the
output of the prediction function. Kearns et al., in their research on fairness gerrymandering [21],
also consider the complexity of subsets evaluated by a classifier, although they are not considering
analogous formalizations of simplicity, and the goals of their work — on auditing and learningtheoretic guarantees in the presence of fairness properties — lie in a different direction from ours.
Finally, recent work has developed some of the equity benefits of explicitly taking group membership
into account in ranking and classification rules [10, 15, 25, 29], although again without incorporating
the simplicity properties of these rules in the analysis.
Our results also have connections with early economic models on discrimination (see [13] for a
review and references). Many of these models are based on scenarios in which employers use race or
38

some other protected attribute as a statistical proxy for variables they do not observe (e.g. [2] and
[33]). As in our model, the disadvantaged group has a worse distribution of inputs; but conditional
on all inputs, the ground truth can be the same between the advantaged and disadvantaged groups.
A key issue in these models, however, distinct from our work, is that the decision-maker only
observes a subset of inputs: Since these unobserved variables are distributionally worse for the
disadvantaged group, membership in that group becomes a negative proxy, and employers will
discriminate against them in a statistical sense. This formalism can thus be viewed as a basic
example of how omitting variables from a model (in this case because they are unobserved) can
lead to discrimination. Our results, in the framework of simple models that we define here, suggest
that this link to discrimination is not specific to the problem of missing variables, but is inherent
to the process of simplification much more generally. And through this more general approach,
we see that the link between simplicity and discrimination does not even rely on the use of group
membership as a proxy since, for example, our first main result applies even to simple functions
that do not use group membership as a variable.

10

Conclusion

Our main results articulate a tension between formal notions of simplicity and equity, for functions
used to rank individuals based on their features. One of our key findings shows that if such
a function is structurally simple — in a certain mathematical sense that captures a number of
current frameworks for building small or interpretable models — then it can be replaced with a
(more complex) function that improves it both in performance and in equity. In other words, the
decision to use a simple rule should not necessarily be viewed as a trade-off between performance
and equity, but as a step that necessarily sacrifices both properties relative to other options in the
design of a rule. Our other main finding is that even when the true underlying function for ranking
does not depend on an individual’s membership in an advantaged or disadvantaged group, any nontrivial simplification of this function creates an incentive to nonetheless use this group membership
information, and in a way that hurts the disadvantaged group. These results point toward a further
dimension in the connection between notions of fairness, simplicity, and interpretability, suggesting
an additional level of subtlety in the way they interact.
Our work suggests several further questions. First, we have focused on a particular notion of
simplicity; while it is general enough to include a number of the main formalisms used for constructing prediction algorithms, including variable selection and decision trees (and it is motivated
in part by psychological notions of categories and conjunctive concepts), it is clear that there are
also other ways in which we could try formalizing the notion of a simple model. We view the set of
potential approaches to formulating these questions as quite broad and promising for exploration,
and it would be interesting to understand the interaction of other such definitions with notions of
equity and fairness.
One common alternative formulation of simplicity is worth noting in this respect: linear approximators. In particular, suppose we simplify f (x), not by clustering distinct inputs into cells, but by
optimally approximating it using a linear function L(x). Linear approximation is not simplification
in the sense of our paper because L can potentially take as many distinct values as f does. But
L does simplify in a different sense: this potentially large set of distinct values is represented compactly as a weighted sum of terms. It is an interesting open question whether our results could be
extended to model simplification through linear approximation (or more generally approximation
39

with a restricted function class). To appreciate one of the challenges inherent in finding the right
formalism, note that linear approximations do not satisfy the “truth-telling” property of the approximators we consider: for a value y taken by a linear function L, if we look at the set of feature
vectors x for which L(x) = y, it is not the case in general that the average f -value in this set is
y. However, the values of a linear approximation satisfy other constrained structural properties,
and understanding how these interact with considerations of equity is an interesting direction for
further exploration.
Similarly, it would be natural to consider the effect of varying other definitions in our framework; for example, while the disadvantage condition we use is motivated by a standard method
for comparing distributions, it would be interesting as noted earlier to understand what results
follow from alternate definitions of disadvantage. Finally, our framework appears to have a rich
mathematical structure; for example, one could investigate the space of approximators that are not
strictly improvable as an object in itself, and to see what the resulting structure suggests about
the trade-offs we make when we choose to simplify our models.

Acknowledgements
We thank Rediet Abebe, Solon Barocas, Fernando Delgado, Christian Hansen, Karen Levy, Jens
Ludwig, Samir Passi, Manish Raghavan, Ashesh Rambachan, David Robinson, Joshua Schwartzstein,
and Jann Spiess for valuable discussions. The work has been supported in part by the MacArthur
Foundation, the Sage Foundation, a George C. Tiao Faculty Fellowship at the University of Chicago
Booth School, and a Simons Investigator Award.

References
[1] Amanda Agan and Sonja Starr. Ban the box, criminal records, and racial discrimination: A
field experiment. Quarterly Journal of Economics, 133(1):191–235, 2018.
[2] Kenneth Arrow. The theory of discrimination. Discrimination in labor markets, 3(10):3–33,
1973.
[3] Susan Athey. Monotone comparative statics under uncertainty. Quarterly Journal of Economics, 117(1):187–223, 2002.
[4] Solon Barocas and Andrew Selbst. Big data’s disparate impact. California Law Review, 104,
2016.
[5] Richard Berk, Hoda Heidari, Shahin Jabbari, Michael Kearns, and Aaron Roth. Fairness in
criminal justice risk assessments: The state of the art. Sociological Methods and Research,
2018.
[6] Colin Blyth. On Simpson’s Paradox and the sure-thing principle. Journal of the American
Statistical Association, 67(338), 1972.
[7] Alexandra Chouldechova. Fair prediction with disparate impact: A study of bias in recidivism
prediction instruments. Big Data, 2017.

40

[8] Alexandra Chouldechova, Diana Benavides Prado, Oleksandr Fialko, and Rhema Vaithianathan. A case study of algorithm-assisted decision making in child maltreatment hotline
screening decisions. In Conference on Fairness, Accountability and Transparency, FAT 2018,,
pages 134–148, 2018.
[9] Sam Corbett-Davies and Sharad Goel. The measure and mismeasure of fairness: A critical
review of fair machine learning. Technical Report 1808.00023, arxiv.org, August 2018.
[10] Sam Corbett-Davies, Emma Pierson, Avi Feller, Sharad Goel, and Aziz Huq. Algorithmic
decision making and the cost of fairness. In Proceedings of the 23rd Conference on Knowledge
Discovery and Data Mining (KDD), 2017.
[11] Finale Doshi-Velez and Been Kim. A roadmap for a rigorous science of interpretability. Technical Report 1702.08608, arxiv.org, February 2017.
[12] Cynthia Dwork, Moritz Hardt, Toniann Pitassi, Omer Reingold, and Richard S. Zemel. Fairness through awareness. In Innovations in Theoretical Computer Science, pages 214–226, 2012.
[13] Hanming Fang and Andrea Moro. Theories of statistical discrimination and affirmative action:
A survey. In Handbook of social economics, volume 1, pages 133–200. Elsevier, 2011.
[14] Michael Feldman, Sorelle Friedler, John Moeller, Carlos Scheidegger, and Suresh Venkatasubramanian. Certifying and removing disparate impact. In Proceedings of the 21st ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining, KDD ’15, pages 259–268,
2015.
[15] Roland Fryer and Glenn Loury. Valuing diversity. Journal of Political Economy, 121(4):747–
774, 2013.
[16] Juan A Garcı́a-Madruga, S Moreno, N Carriedo, F Gutiérrez, and PN Johnson-Laird. Are
conjunctive inferences easier than disjunctive inferences? A comparison of rules and models.
The Quarterly Journal of Experimental Psychology: Section A, 54(2):613–632, 2001.
[17] Bryce Goodman and Seth R. Flaxman. European union regulations on algorithmic decisionmaking and a ”right to explanation”. AI Magazine, 38(3):50–57, 2017.
[18] Anthony G. Greenwald and Mahzarin R. Banaji. Implicit social cognition: Attitudes, selfesteem, and stereotypes. Psychological Review, 102(1):4–27, 1995.
[19] Trevor Hastie, Robert Tibshirani, and Jerome Friedman. The Elements of Statistical Learning:
Data Mining, Inference, and Prediction. Springer, 2009.
[20] Ed Hopkins and Tatiana Kornienko. Ratio orderings and comparative statics. Technical
Report 91, Edinburgh School of Economics Discussion Paper Series, 2003.
[21] Michael J. Kearns, Seth Neel, Aaron Roth, and Zhiwei Steven Wu. Preventing fairness gerrymandering: Auditing and learning for subgroup fairness. In Proceedings of the 35th International Conference on Machine Learning, ICML, pages 2569–2577, 2018.

41

[22] Jon Kleinberg, Hima Lakkaraju, Jure Leskovec, Jens Ludwig, and Sendhil Mullainathan. Human decisions and machine predictions. Quarterly Journal of Economics, 133(1):237–293,
2018.
[23] Jon Kleinberg, Jens Ludwig, Sendhil Mullainathan, and Ziad Obermeyer. Prediction policy
problems. American Economic Review, 105(5):491–95, 2015.
[24] Jon Kleinberg, Jens Ludwig, Sendhil Mullainathan, and Ashesh Rambachan. Algorithmic
bias and the social welfare function: Regulating outputs versus regulating algorithms, 2018.
Working paper.
[25] Jon Kleinberg, Jens Ludwig, Sendhil Mullainathan, and Ashesh Rambachan. Algorithmic
fairness. AEA Papers and Proceedings, pages 22–27, 2018.
[26] Jon Kleinberg, Sendhil Mullainathan, and Manish Raghavan. Inherent trade-offs in the fair
determination of risk scores. In 8th Innovations in Theoretical Computer Science Conference,
ITCS, 2017.
[27] Jacques-Philippe Leyens, Vincent Y.A. Yzerbyt, and Georges Schadron. Stereotypes and Social
Cognition. Sage Publications, 1994.
[28] Zachary C. Lipton. The mythos of model interpretability. Communications of the ACM,
61(10):36–43, 2018.
[29] Zachary Chase Lipton, Alexandra Chouldechova, and Julian McAuley. Does mitigating ML’s
impact disparity require treatment disparity? Technical Report 1711.07076, arxiv.org, November 2017.
[30] Paul R. Milgrom. Good news and bad news: Representation theorems and applications. Bell
Journal of Economics, 12:380–391, 1981.
[31] Sendhil Mullainathan. Thinking through categories, 2000. Working paper.
[32] Sendhil Mullainathan, Joshua Schwartzstein, and Andrei Shleifer. Coarse thinking and persuasion. Quarterly Journal of Economics, 123(2):577–619, 2008.
[33] Edmund S Phelps. The statistical theory of racism and sexism. American Economic Review,
pages 659–661, 1972.
[34] Jonah E. Rockoff, Brian A. Jacob, Thomas J. Kane, and Douglas O. Staiger. Can you recognize
an effective teacher when you recruit one? Education Finance and Policy, 6(1):43–74, 2011.
[35] Eleanor Rosch and Barbara Bloom Lloyd. Cognition and categorization. Lawrence Erlbaum
Associates Hillsdale, NJ, 1978.
[36] Megan Stevenson. Assessing risk assessment in action. Minnesota Law Review, 103, 2018.
[37] Elmar Wolfstetter. Topics in Microeconomics. Cambridge University Press, 1999.
[38] Jiaming Zeng, Berk Ustun, and Cynthia Rudin. Interpretable classification models for recidivism prediction. Journal of the Royal Statistical Society: Series A, 180(3):689–722, 2017.

42

Appendix A. Every Approximator Can Be Improved by a Maximal
Approximator
In this appendix, we provide a proof of (3.8), that for every f -approximator, there is a maximal
f -approximator that weakly improves it. Thus, we start with an arbitrary f -approximator g,
consisting of cells C1 , . . . , Cd , with d ≤ B for our absolute bound on the number of allowable cells.
Each cell Ci is described by a vector φi = (φi (x1 ), . . . , φi (xm )) where x1 , . . . , xm is an enumeration
of all m = 2k+1 rows, and φi (xj ) specifies the measure of row xi assigned to cell Ci .
To find a maximal f -approximator that weakly improves g, we will work with a representation
of f -approximators as points in Euclidean space, so that we can eventually use an argument based
on compactness and continuity. We say that an f -synthesizer is a vector of values ψ = (ψij : 1 ≤
i ≤ B; 1 ≤ j ≤ m), where ψij is intended to represent the value φi (xj ) associated with g. (Below,
we will deal with the issue that ψ is indexed all the way out to B, while g may have only d < B
cells.) For ψ to faithfully represent the values φi (xj ), we impose the following constraints on it.
• ψij ≥ 0 for all 1 ≤ i ≤ B and 1 ≤ j ≤ m.
PB
•
i=1 ψij = µ(xj ) for all 1 ≤ j ≤ m, so that each row is completely allocated across the cells.
P
P
• Finally, the cells C1 , . . . , Cd of g are sorted in descending order of θ(Ci ) = x φi (x)f (x)/ x φi (x);
the condition θ(Ch ) ≥ θ(Ci ) for h ≤ i can be equivalently written as
!
!
!
!
X
X
X
X
φh (x)f (x)
φi (x) −
φi (x)f (x)
φh (x) ≥ 0.
x

x

x

x

We therefore impose the following constraint on ψ, for all 1 ≤ i ≤ j ≤ B.




 
m
m
m
m
X
X
X
X

ψhj f (xj ) 
ψij  − 
ψhj  ≥ 0.
ψij f (xj ) 
j=1

j=1

j=1

(6)

j=1

As noted above, this naturally represents approximators that have exactly B cells. For
approximators that have d < B cells, we adopt a slightly unusual convention that makes the
representation in Euclidean space easier. In particular, if g has d < B cells, then we also
declare that g has B − d empty cells. Each empty cell Ci has associated vector φi = 0, and
it can come anywhere in the sorted order. We will not attempt to define a value θ(Ci ) for
an empty cell; but this will not pose a problem, since no portion of the population belongs
to this cell. Now, wherever we place the empty cells in the sorted order, they will satisfy
Inequality (6) (since they will produce a left-hand side of 0 with respect to any other cell).
The intersection of these constraints defines the set of f -synthesizers K ⊆ RmB . Note that the
set K is a closed and bounded subset of Euclidean space, and hence compact. Every f -approximator
g with d cells can be naturally mapped to an f -synthesizer in K: we simply concatenate B − d
empty cells to the end of g’s list of cells, and write ψij for φi (xj ). We can check that all the
constraints are satisfied. Conversely,
P given any f -synthesizer ψ, we can create an f -approximator
g as follows: for every i such that m
j=1 ψij > 0, we create a cell of g with φi (xj ) = ψij . These cells
will be arranged in decreasing order of θ-value, and every row will be completely allocated across
the cells.
43

For a vector ψ ∈ K, let g(ψ) be the approximator produced by this construction, and let λ(ψ)
be the univariate function vg(ψ) (·). As discussed earlier in the text, this function vg(ψ) (·) = λ(ψ) is
piecewise constant, with an interval over which it is constant for each cell, and a finite set of points of
discontinuity corresponding to the points between consecutive cells. Let Λr (ψ) be the value of Vg (r)
for this f -approximator g(ψ). If ψ h1i , ψ h2i , ψ h3i , . . . is a convergent sequence in K with limit ψ ∗ , then
the functions λ(ψ h1i ), λ(ψ h2i ), λ(ψ h3i ), . . . converge pointwise to the function λ(ψ ∗ ) except possibly
at its finite set of points of discontinuity. It follows that the values Λr (ψ h1i ), Λr (ψ h2i ), Λr (ψ h3i ), . . .
converge to Λr (ψ ∗ ).
We conclude two things from this argument. First, the function Λr (·) is a continuous function
on K, and second, for any ψ0 ∈ K, the set L(r, ψ0 ) of all ψ for which Λr (ψ) ≥ Λr (ψ0 ) is a closed
subset of K. Moreover, if we define Γr (ψ) to be the value of Wg(ψ) (r), then the same argument
can be applied to Γr , showing that Γr (·) is continuous, and the set M (r, ψ0 ) of all ψ for which
Γr (ψ) ≥ Γr (ψ0 ) is a closed subset of K.
Now, given an f -approximator g, we would like to use these definitions to construct a maximal
f -approximator that weakly improves g. First, we choose an f -synthesizer ψ0 such that g(ψ0 ) = g.
Next, we define a set intended to represent all f -approximators that weakly improve on g(ψ0 ).
Specifically, we define
\
\
N (ψ0 ) = K ∩
L(r, ψ0 ) ∩
M (r, ψ0 ).
0<r<1

0<r<1

This is an intersection of closed sets, and hence it is closed; since it also bounded, it is a compact
set. It also non-empty, since it contains
R 1 ψ0 .
Finally, for ψ ∈ K, let Ω(ψ) = 0 Vg(ψ) (t) dt. This is a continuous function of ψ; therefore,
since N (ψ0 ) is a compact set, the maximum value of Ω over the set N (ψ0 ) is assumed at some
non-empty subset of N (ψ0 ). Let ψ + be a point in this subset.
Consider the f -approximator g + = g(ψ + ); we claim that g + is maximal. For if not, there would
be a point ψ 0 ∈ N (ψ0 ) such that Vg(ψ0 ) (r) ≥ Vg(ψ+ ) (r) for all r, and Vg(ψ0 ) (r∗ ) > Vg(ψ+ ) (r∗ ) for
some r∗ . Since Vg(ψ0 ) (·) and Vg(ψ+ ) (·) are continuous functions, it would follow that Ω(ψ 0 ) > Ω(ψ + ),
contradicting the assumption that Ω assumes its maximum value in N (ψ0 ) at the point ψ + .
Since we have constructed a maximal f -approximator g + that weakly improves g, this completes
the proof of (3.8)

Appendix B. Comparing Random Variables
In this section, we provide a proof of (5.2). It is useful to state it in a more expansive form that
brings in an additional property. The resulting formal statement is standard in the literature on
comparing random variables [20, 37], and our proof is purely for the sake of completeness, to cast
it in our current discrete formalism.
(B.1) (See e.g. [20, 37]) Consider two discrete random variables P and Q, each of which
takes values in {u1 , uP
with u1 < u2 < · · · < un P
and n > 1. Let pi = Pr
2 , . . . , un }, P
P[Pi = ui ] and
qi = Pr [Qi = ui ]; so ni=1 pi = ni=1 qi = 1, and E [P ] = ni=1 pi ui and E [Q] = ni=1 qi ui . We
will assume that pi > 0 and qi > 0 for all i.
Consider three different comparisons between Q and P :
(i) Expectation Dominance: E [Q] > E [P ].

44

(ii) First-Order Stochastic Dominance: For all t such that u1 ≤ t < un , we have Pr [Q > t] >
Pr [P > t].
(iii) Likelihood Ratio Dominance: The sequence of ratios {qi /pi } is strictly monotonically increasing.
For all pairs of random variables Q and P as above, condition (iii) implies condition (ii), and
condition (ii) implies condition (i).
P
P
Proof of (B.1). We define p+
= Pr [P ≤ ui ] = i`=1 p` and qi+ = PrP
[Q ≤ ui ] = i`=1 q` ; note that
iP
n
+
then 1 − p+
ui ] = Pn`=i+1 q` .
`=i+1 p` and 1 − qi = Pr [Q
i = Pr [P > ui ] =
P>
n
We first show that (iii) implies condition (ii). Since i=1 pi = ni=1 qi = 1, we cannot have
pi ≥ qi for all i or pi ≤ qi for all i. Thus, by Likelihood
Ratio Dominance, we P
have pi > qP
i up to some
P∗
i = i∗ , and then pi ≤ qi for i > i∗ . Let ε = ii=1 (pi − qi ). Note that since ni=1 pi = ni=1 qi = 1,
P
P
we also have ε = ni=i∗ +1 (qi − pi ), and hence `i=i∗ +1 (qi − pi ) < ε for ` < n.
∗
We would like to show that qi+ < p+
i for all i < n. For i ≤ i , this follows simply because qi < pi
for all such i. For i > i∗ , we have
i
X

∗

(qi − pi ) =

j=1

i
X
j=1

i
X

(qi − pi ) +

(qi − pi ) < −ε + ε = 0,

j=i∗ +1

∗
and hence qi+ < p+
i for i > i as well. This shows that condition (iii) implies condition (ii).
We now show that condition (ii) implies condition (i). Let εi = ui − ui−1 > 0. We have

E [P ] =

n
X

pi ui

i=1

= p1 u1 + p2 (u1 + ε2 ) + p3 (u1 + ε2 + ε3 ) + · · ·
+ pn (u1 + ε2 + ε3 + · · · + εn )
+
+
= u1 + (1 − p+
1 )ε2 + (1 − p2 )ε3 + · · · + (1 − pn−1 )εn ,

P
where we pass from the first line to the second line by writing ui as u1 + ij=2 εj , and we pass from
the second line to the third line by collecting together all the pi that are multiplied by each εj .
Analogously, we have
+
E [Q] = u1 + (1 − q1+ )ε2 + (1 − q2+ )ε3 + · · · + (1 − qn−1
)εn .

Now, using the fact that n > 1 and 1 − qi+ > 1 − p+
i for all i < n, we obtain E [Q] > E [P ] .

45

